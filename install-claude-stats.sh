#!/bin/bash
set -e

# Claude Code Session Stats Tracking - Automated Installer
# Supports: Linux, macOS, Windows (WSL/Git Bash)

# Read version from VERSION file
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VERSION="0.0.1"
if [ -f "$SCRIPT_DIR/VERSION" ]; then
  VERSION=$(cat "$SCRIPT_DIR/VERSION" | tr -d '[:space:]')
fi

echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘   Claude Code Session Stats Tracking - Installer          â•‘"
echo "â•‘   Version: $VERSION                                        â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Detect operating system
OS="unknown"
if [[ "$OSTYPE" == "linux-gnu"* ]]; then
  OS="linux"
elif [[ "$OSTYPE" == "darwin"* ]]; then
  OS="macos"
elif [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]] || [[ "$OSTYPE" == "win32" ]]; then
  OS="windows"
else
  # Check for WSL
  if grep -qi microsoft /proc/version 2>/dev/null; then
    OS="linux"
  fi
fi

echo "âœ“ Detected OS: $OS"
echo ""

# Check prerequisites
echo "Checking prerequisites..."

# Check for jq
if ! command -v jq &> /dev/null; then
  echo "âŒ jq is not installed"
  echo ""
  echo "Please install jq first:"
  case "$OS" in
    linux)
      echo "  Ubuntu/Debian: sudo apt-get install -y jq"
      echo "  RHEL/Fedora:   sudo dnf install -y jq"
      echo "  Arch:          sudo pacman -S jq"
      ;;
    macos)
      echo "  macOS:         brew install jq"
      ;;
    windows)
      echo "  WSL:           sudo apt-get install -y jq"
      echo "  Git Bash:      Download from https://stedolan.github.io/jq/"
      ;;
  esac
  exit 1
fi
echo "âœ“ jq is installed ($(jq --version))"

# Check for bc
if ! command -v bc &> /dev/null; then
  echo "âŒ bc is not installed"
  echo ""
  echo "Please install bc first:"
  case "$OS" in
    linux)
      echo "  Ubuntu/Debian: sudo apt-get install -y bc"
      echo "  RHEL/Fedora:   sudo dnf install -y bc"
      ;;
    macos)
      echo "  bc is pre-installed on macOS"
      ;;
    windows)
      echo "  bc is usually included with Git Bash"
      ;;
  esac
  exit 1
fi
echo "âœ“ bc is installed"

echo ""
echo "Configuring billing mode..."
echo ""
echo "Which billing mode are you using?"
echo "  1) API Billing (pay-per-use, charged per API call)"
echo "  2) Subscription Plan (monthly subscription with included usage)"
echo ""

# Read user input with validation
while true; do
  read -p "Enter your choice (1 or 2): " BILLING_CHOICE
  case "$BILLING_CHOICE" in
    1)
      BILLING_MODE="API"
      BILLING_ICON="ğŸ’³"
      echo "âœ“ Selected: API Billing"
      break
      ;;
    2)
      BILLING_MODE="Sub"
      BILLING_ICON="ğŸ“…"
      echo "âœ“ Selected: Subscription Plan"
      break
      ;;
    *)
      echo "âŒ Invalid choice. Please enter 1 or 2."
      ;;
  esac
done

echo ""
echo "Creating directories..."

# Create directories
mkdir -p ~/.claude/hooks
mkdir -p ~/.claude/commands

echo "âœ“ Created ~/.claude/hooks"
echo "âœ“ Created ~/.claude/commands"

# Save billing mode configuration
cat > ~/.claude/hooks/.stats-config << CONFIG_EOF
# Claude Code Session Stats Configuration
# Generated by install-claude-stats.sh
BILLING_MODE="$BILLING_MODE"
BILLING_ICON="$BILLING_ICON"
CONFIG_EOF

echo "âœ“ Saved billing configuration to ~/.claude/hooks/.stats-config"
echo ""

echo "Installing scripts..."

# Create brief-stats.sh (status line)
cat > ~/.claude/hooks/brief-stats.sh << 'SCRIPT_EOF'
#!/bin/bash
# Brief session statistics displayed in the status line
# Claude Code Session Stats - Version 0.4.2

# Force C locale for consistent number formatting
export LC_NUMERIC=C

# Try to read session info from stdin (provided by Claude Code in statusLine context)
# Read with a 1 second timeout - if nothing arrives, assume no session
if IFS= read -t 1 -r INPUT; then
  # If we got one line, try to read the rest (for multi-line JSON)
  while IFS= read -t 1 -r line; do
    INPUT="${INPUT}${line}"
  done
else
  INPUT=""
fi

# Extract session ID from JSON input if available
ACTIVE_SESSION_ID=$(echo "$INPUT" | jq -r '.sessionId // empty' 2>/dev/null)

# Find the project directory
PROJECT_DIR=$(pwd | sed 's/\//-/g' | sed 's/_/-/g')
TRANSCRIPT_DIR="$HOME/.claude/projects/$PROJECT_DIR"

# Check for active sub-agents with robust detection
if [ -d "$TRANSCRIPT_DIR" ]; then
  NOW=$(date +%s)
  ACTIVE_AGENTS=0

  # Iterate through agent files if they exist
  for agent_file in "$TRANSCRIPT_DIR"/agent-*.jsonl; do
    # Check if file exists (glob may not match anything)
    if [ -f "$agent_file" ]; then
      # Get file modification time (Linux uses -c, macOS uses -f)
      FILE_MTIME=$(stat -c %Y "$agent_file" 2>/dev/null || stat -f %m "$agent_file" 2>/dev/null || echo 0)
      AGE=$((NOW - FILE_MTIME))

      # Multi-criteria check for active agents:
      # 1. File modified in last 3 seconds (stricter window to avoid false positives from old sessions)
      # 2. File size > 100 bytes (not just init/empty file)
      # 3. File is actively growing (check size twice with small delay)
      if [ "$AGE" -lt 3 ]; then
        # Get file size (Linux uses -c %s, macOS uses -f %z)
        FILE_SIZE_1=$(stat -c %s "$agent_file" 2>/dev/null || stat -f %z "$agent_file" 2>/dev/null || echo 0)

        # Check if file has meaningful content (> 100 bytes)
        if [ "$FILE_SIZE_1" -gt 100 ]; then
          # Wait briefly and check if file is still growing (active write)
          sleep 0.1
          FILE_SIZE_2=$(stat -c %s "$agent_file" 2>/dev/null || stat -f %z "$agent_file" 2>/dev/null || echo 0)

          # If file grew, it's actively being written to
          if [ "$FILE_SIZE_2" -gt "$FILE_SIZE_1" ]; then
            ACTIVE_AGENTS=1
            break
          fi
        fi
      fi
    fi
  done

  if [ "$ACTIVE_AGENTS" -eq 1 ]; then
    echo "ğŸ¤– Sub-agents running, stand by..."
    exit 0
  fi
fi

# Load billing mode from config file (needed for zeroed stats display)
CONFIG_FILE="$HOME/.claude/hooks/.stats-config"
if [ -f "$CONFIG_FILE" ]; then
  source "$CONFIG_FILE"
else
  # Fallback to defaults if config doesn't exist
  BILLING_MODE="API"
  BILLING_ICON="ğŸ’³"
fi

# If we have an active session ID, use it directly
if [ -n "$ACTIVE_SESSION_ID" ]; then
  TRANSCRIPT_PATH="$TRANSCRIPT_DIR/${ACTIVE_SESSION_ID}.jsonl"

  # If the transcript doesn't exist yet (new session), show zeroed stats
  if [ ! -f "$TRANSCRIPT_PATH" ]; then
    echo "ğŸ’¬ 0 msgs | ğŸ”§ 0 tools | ğŸ¯ 0 tok | âš¡ 0% eff | $BILLING_ICON ~\$0.0000 (\$0.00/msg) | ğŸ“Š /trip-computer"
    exit 0
  fi
else
  # No active session ID - fall back to most recent transcript
  if [ -d "$TRANSCRIPT_DIR" ]; then
    TRANSCRIPT_PATH=$(ls -t "$TRANSCRIPT_DIR"/*.jsonl 2>/dev/null | grep -v agent | head -1)
    if [ -z "$TRANSCRIPT_PATH" ]; then
      # No transcripts exist - show zeroed stats
      echo "ğŸ’¬ 0 msgs | ğŸ”§ 0 tools | ğŸ¯ 0 tok | âš¡ 0% eff | $BILLING_ICON ~\$0.0000 (\$0.00/msg) | ğŸ“Š /trip-computer"
      exit 0
    fi
  else
    # New directory - show zeroed stats
    echo "ğŸ’¬ 0 msgs | ğŸ”§ 0 tools | ğŸ¯ 0 tok | âš¡ 0% eff | $BILLING_ICON ~\$0.0000 (\$0.00/msg) | ğŸ“Š /trip-computer"
    exit 0
  fi
fi

# Calculate statistics from current session only
# Count messages and tool calls from current transcript
# Count only direct user prompts (exclude tool results, meta messages, and command messages)
USER_MESSAGES=$(jq -s '[.[] | select(.type == "user" and (.isMeta != true) and (.message.content | if type == "array" then all(.[]; .type != "tool_result") else (test("<command-name>|<command-args>|<local-command-stdout>|<command-message>") | not) end))] | length' "$TRANSCRIPT_PATH" 2>/dev/null || echo "0")

# Count tool uses - they are nested inside message.content arrays
TOOL_CALLS=$(jq -s '[.[] | select(.type == "assistant") | .message.content[]? | select(.type == "tool_use")] | length' "$TRANSCRIPT_PATH" 2>/dev/null || echo "0")

# Parse current transcript and group by requestId + model
PER_MODEL_DATA=$(jq -s '
[.[] | select(.message.usage and .message.model)] |
group_by(.requestId + "|" + .message.model) |
map({
  requestId: .[0].requestId,
  model: .[0].message.model,
  input: (map(.message.usage.input_tokens // 0) | max),
  output: (map(.message.usage.output_tokens // 0) | max),
  cache_creation: (map(.message.usage.cache_creation_input_tokens // 0) | max),
  cache_read: (map(.message.usage.cache_read_input_tokens // 0) | max)
}) |
group_by(.model) |
map({
  model: .[0].model,
  input: (map(.input) | add),
  output: (map(.output) | add),
  cache_creation: (map(.cache_creation) | add),
  cache_read: (map(.cache_read) | add)
})
' "$TRANSCRIPT_PATH" 2>/dev/null || echo '[]')

# Calculate totals across all models
INPUT_TOKENS=$(echo "$PER_MODEL_DATA" | jq '[.[].input] | add // 0')
OUTPUT_TOKENS=$(echo "$PER_MODEL_DATA" | jq '[.[].output] | add // 0')
CACHE_CREATION_TOKENS=$(echo "$PER_MODEL_DATA" | jq '[.[].cache_creation] | add // 0')
CACHE_READ_TOKENS=$(echo "$PER_MODEL_DATA" | jq '[.[].cache_read] | add // 0')

# Calculate total tokens
TOTAL_TOKENS=$((INPUT_TOKENS + OUTPUT_TOKENS + CACHE_CREATION_TOKENS + CACHE_READ_TOKENS))

# Format tokens in industry standard abbreviation (K for thousands, M for millions)
if [ $TOTAL_TOKENS -ge 1000000 ]; then
  # Millions
  FORMATTED_TOKENS=$(echo "scale=1; $TOTAL_TOKENS / 1000000" | bc 2>/dev/null || echo "0")
  # Handle bc output starting with .
  if [[ "$FORMATTED_TOKENS" == .* ]]; then
    FORMATTED_TOKENS="0$FORMATTED_TOKENS"
  fi
  FORMATTED_TOKENS="${FORMATTED_TOKENS}M"
elif [ $TOTAL_TOKENS -ge 1000 ]; then
  # Thousands
  FORMATTED_TOKENS=$(echo "scale=1; $TOTAL_TOKENS / 1000" | bc 2>/dev/null || echo "0")
  if [[ "$FORMATTED_TOKENS" == .* ]]; then
    FORMATTED_TOKENS="0$FORMATTED_TOKENS"
  fi
  FORMATTED_TOKENS="${FORMATTED_TOKENS}K"
else
  # Less than 1000
  FORMATTED_TOKENS="$TOTAL_TOKENS"
fi

# Helper function to get pricing for a model
get_model_pricing() {
  local model_name="$1"
  local input_rate output_rate cache_write_mult cache_read_mult

  if [[ "$model_name" == *"opus-4-5"* ]] || [[ "$model_name" == *"opus-4.5"* ]]; then
    input_rate=5; output_rate=25; cache_write_mult=1.25; cache_read_mult=0.10
  elif [[ "$model_name" == *"opus-4"* ]] || [[ "$model_name" == *"opus-3"* ]] || [[ "$model_name" == *"opus"* ]]; then
    input_rate=15; output_rate=75; cache_write_mult=1.25; cache_read_mult=0.10
  elif [[ "$model_name" == *"haiku-4-5"* ]] || [[ "$model_name" == *"haiku-4.5"* ]]; then
    input_rate=1; output_rate=5; cache_write_mult=1.25; cache_read_mult=0.10
  elif [[ "$model_name" == *"haiku-3-5"* ]] || [[ "$model_name" == *"haiku-3.5"* ]]; then
    input_rate=0.80; output_rate=4; cache_write_mult=1.25; cache_read_mult=0.10
  elif [[ "$model_name" == *"haiku-3"* ]] || [[ "$model_name" == *"haiku"* ]]; then
    input_rate=0.25; output_rate=1.25; cache_write_mult=1.20; cache_read_mult=0.12
  else
    input_rate=3; output_rate=15; cache_write_mult=1.25; cache_read_mult=0.10
  fi

  echo "$input_rate $output_rate $cache_write_mult $cache_read_mult"
}

# Calculate costs per model and sum
TOTAL_COST=0
MODEL_COUNT=$(echo "$PER_MODEL_DATA" | jq 'length')
for ((i=0; i<MODEL_COUNT; i++)); do
  MODEL_NAME=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].model")
  MODEL_INPUT=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].input")
  MODEL_OUTPUT=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].output")
  MODEL_CACHE_WRITE=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].cache_creation")
  MODEL_CACHE_READ=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].cache_read")

  read INPUT_RATE OUTPUT_RATE CACHE_WRITE_MULT CACHE_READ_MULT < <(get_model_pricing "$MODEL_NAME")

  MODEL_COST=$(echo "scale=4; \
    ($MODEL_INPUT * $INPUT_RATE / 1000000) + \
    ($MODEL_OUTPUT * $OUTPUT_RATE / 1000000) + \
    ($MODEL_CACHE_WRITE * $INPUT_RATE * $CACHE_WRITE_MULT / 1000000) + \
    ($MODEL_CACHE_READ * $INPUT_RATE * $CACHE_READ_MULT / 1000000)" | bc 2>/dev/null || echo "0")

  [[ "$MODEL_COST" == .* ]] && MODEL_COST="0$MODEL_COST"
  TOTAL_COST=$(echo "scale=4; $TOTAL_COST + $MODEL_COST" | bc 2>/dev/null || echo "0")
  [[ "$TOTAL_COST" == .* ]] && TOTAL_COST="0$TOTAL_COST"
done

# Format cost - handle bc output that starts with . (like .8809 -> 0.8809)
if [[ "$TOTAL_COST" == .* ]]; then
  TOTAL_COST="0$TOTAL_COST"
fi
FORMATTED_COST=$(printf "%.4f" "$TOTAL_COST" 2>/dev/null || echo "0.0000")

# Calculate cost per message for trajectory indicator
COST_PER_MESSAGE="0.00"
if [ "$USER_MESSAGES" -gt 0 ]; then
  COST_PER_MESSAGE=$(echo "scale=2; $TOTAL_COST / $USER_MESSAGES" | bc 2>/dev/null || echo "0.00")
  [[ "$COST_PER_MESSAGE" == .* ]] && COST_PER_MESSAGE="0$COST_PER_MESSAGE"
fi

# Calculate cache efficiency percentage
TOTAL_CACHE_TOKENS=$((CACHE_CREATION_TOKENS + CACHE_READ_TOKENS))
CACHE_EFFICIENCY="0"
if [ "$TOTAL_CACHE_TOKENS" -gt 0 ]; then
  CACHE_EFFICIENCY=$(echo "scale=0; 100 * $CACHE_READ_TOKENS / $TOTAL_CACHE_TOKENS" | bc 2>/dev/null || echo "0")
  [[ "$CACHE_EFFICIENCY" == .* ]] && CACHE_EFFICIENCY="0"
fi

# Output brief stats (single line for status bar) with billing mode indicator, cache efficiency, cost per message, and trip computer pointer
# Format: msgs | tools | tokens | cache eff | cost (cost/msg) | trip computer pointer
echo "ğŸ’¬ $USER_MESSAGES msgs | ğŸ”§ $TOOL_CALLS tools | ğŸ¯ ${FORMATTED_TOKENS} tok | âš¡ ${CACHE_EFFICIENCY}% eff | $BILLING_ICON ~\$$FORMATTED_COST (\$$COST_PER_MESSAGE/msg) | ğŸ“Š /trip-computer"

exit 0
SCRIPT_EOF

chmod +x ~/.claude/hooks/brief-stats.sh
echo "âœ“ Installed brief-stats.sh (status line)"

# Create show-session-stats.sh (detailed stats - enhanced "trip computer" version)
cat > ~/.claude/hooks/show-session-stats.sh << 'SCRIPT_EOF'
#!/bin/bash
set -e

# Helper script to display session statistics for current or specified session
# Claude Code Session Stats - Version 0.4.0
# Usage: ./show-session-stats.sh [session_id]

# Force en_US locale for consistent number formatting with commas as thousand separators
export LC_NUMERIC=en_US.UTF-8

# If session_id provided, use it; otherwise find the most recent session
if [ -n "$1" ]; then
  SESSION_ID="$1"
else
  # Find the most recent transcript file for this project
  PROJECT_DIR=$(pwd | sed 's/\//-/g' | sed 's/_/-/g')
  TRANSCRIPT_DIR="$HOME/.claude/projects/$PROJECT_DIR"

  if [ -d "$TRANSCRIPT_DIR" ]; then
    TRANSCRIPT_PATH=$(ls -t "$TRANSCRIPT_DIR"/*.jsonl 2>/dev/null | grep -v agent | head -1)
    if [ -z "$TRANSCRIPT_PATH" ]; then
      echo "âŒ No session transcripts found in $TRANSCRIPT_DIR"
      exit 1
    fi
    SESSION_ID=$(basename "$TRANSCRIPT_PATH" .jsonl)
  else
    echo "âŒ No transcript directory found for this project"
    exit 1
  fi
fi

# Construct transcript path
PROJECT_DIR=$(pwd | sed 's/\//-/g' | sed 's/_/-/g')
TRANSCRIPT_PATH="$HOME/.claude/projects/$PROJECT_DIR/${SESSION_ID}.jsonl"

if [ ! -f "$TRANSCRIPT_PATH" ]; then
  echo "âŒ Transcript file not found: $TRANSCRIPT_PATH"
  exit 1
fi

# Load billing mode from config file
CONFIG_FILE="$HOME/.claude/hooks/.stats-config"
BILLING_MODE="API"
BILLING_ICON="ğŸ’³"
if [ -f "$CONFIG_FILE" ]; then
  source "$CONFIG_FILE"
fi

# ============================================================================
# TRANSCRIPT ANALYSIS - Calculate estimates from session transcript
# ============================================================================

# Count messages and tool calls from current transcript
USER_MESSAGES=$(jq -s '[.[] | select(.type == "user" and (.isMeta != true) and (.message.content | if type == "array" then all(.[]; .type != "tool_result") else (test("<command-name>|<command-args>|<local-command-stdout>|<command-message>") | not) end))] | length' "$TRANSCRIPT_PATH")

TOOL_CALLS=$(jq -s '[.[] | select(.type == "assistant") | .message.content[]? | select(.type == "tool_use")] | length' "$TRANSCRIPT_PATH")

# Parse transcript and group by requestId + model to avoid double-counting
PER_MODEL_DATA=$(jq -s '
[.[] | select(.message.usage and .message.model)] |
group_by(.requestId + "|" + .message.model) |
map({
  requestId: .[0].requestId,
  model: .[0].message.model,
  input: (map(.message.usage.input_tokens // 0) | max),
  output: (map(.message.usage.output_tokens // 0) | max),
  cache_creation: (map(.message.usage.cache_creation_input_tokens // 0) | max),
  cache_read: (map(.message.usage.cache_read_input_tokens // 0) | max)
}) |
group_by(.model) |
map({
  model: .[0].model,
  input: (map(.input) | add),
  output: (map(.output) | add),
  cache_creation: (map(.cache_creation) | add),
  cache_read: (map(.cache_read) | add)
})
' "$TRANSCRIPT_PATH" 2>/dev/null || echo '[]')

# Calculate totals
INPUT_TOKENS=$(echo "$PER_MODEL_DATA" | jq '[.[].input] | add // 0')
OUTPUT_TOKENS=$(echo "$PER_MODEL_DATA" | jq '[.[].output] | add // 0')
CACHE_CREATION_TOKENS=$(echo "$PER_MODEL_DATA" | jq '[.[].cache_creation] | add // 0')
CACHE_READ_TOKENS=$(echo "$PER_MODEL_DATA" | jq '[.[].cache_read] | add // 0')
TOTAL_TOKENS=$((INPUT_TOKENS + OUTPUT_TOKENS + CACHE_CREATION_TOKENS + CACHE_READ_TOKENS))

# Helper function to get pricing for a model
get_model_pricing() {
  local model_name="$1"
  local input_rate output_rate cache_write_mult cache_read_mult

  if [[ "$model_name" == *"opus-4-5"* ]] || [[ "$model_name" == *"opus-4.5"* ]]; then
    input_rate=5; output_rate=25; cache_write_mult=1.25; cache_read_mult=0.10
  elif [[ "$model_name" == *"opus-4"* ]] || [[ "$model_name" == *"opus-3"* ]] || [[ "$model_name" == *"opus"* ]]; then
    input_rate=15; output_rate=75; cache_write_mult=1.25; cache_read_mult=0.10
  elif [[ "$model_name" == *"haiku-4-5"* ]] || [[ "$model_name" == *"haiku-4.5"* ]]; then
    input_rate=1; output_rate=5; cache_write_mult=1.25; cache_read_mult=0.10
  elif [[ "$model_name" == *"haiku-3-5"* ]] || [[ "$model_name" == *"haiku-3.5"* ]]; then
    input_rate=0.80; output_rate=4; cache_write_mult=1.25; cache_read_mult=0.10
  elif [[ "$model_name" == *"haiku-3"* ]] || [[ "$model_name" == *"haiku"* ]]; then
    input_rate=0.25; output_rate=1.25; cache_write_mult=1.20; cache_read_mult=0.12
  else
    input_rate=3; output_rate=15; cache_write_mult=1.25; cache_read_mult=0.10
  fi

  echo "$input_rate $output_rate $cache_write_mult $cache_read_mult"
}

# Calculate estimated costs per model
ESTIMATE_TOTAL_COST=0
MODEL_COUNT=$(echo "$PER_MODEL_DATA" | jq 'length')
for ((i=0; i<MODEL_COUNT; i++)); do
  MODEL_NAME=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].model")
  MODEL_INPUT=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].input")
  MODEL_OUTPUT=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].output")
  MODEL_CACHE_WRITE=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].cache_creation")
  MODEL_CACHE_READ=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].cache_read")

  read INPUT_RATE OUTPUT_RATE CACHE_WRITE_MULT CACHE_READ_MULT < <(get_model_pricing "$MODEL_NAME")

  MODEL_COST=$(echo "scale=4; \
    ($MODEL_INPUT * $INPUT_RATE / 1000000) + \
    ($MODEL_OUTPUT * $OUTPUT_RATE / 1000000) + \
    ($MODEL_CACHE_WRITE * $INPUT_RATE * $CACHE_WRITE_MULT / 1000000) + \
    ($MODEL_CACHE_READ * $INPUT_RATE * $CACHE_READ_MULT / 1000000)" | bc)

  [[ "$MODEL_COST" == .* ]] && MODEL_COST="0$MODEL_COST"
  ESTIMATE_TOTAL_COST=$(echo "scale=4; $ESTIMATE_TOTAL_COST + $MODEL_COST" | bc)
  [[ "$ESTIMATE_TOTAL_COST" == .* ]] && ESTIMATE_TOTAL_COST="0$ESTIMATE_TOTAL_COST"
done

# Calculate cache efficiency
TOTAL_CACHE_TOKENS=$((CACHE_CREATION_TOKENS + CACHE_READ_TOKENS))
CACHE_EFFICIENCY=0
if [ "$TOTAL_CACHE_TOKENS" -gt 0 ]; then
  CACHE_EFFICIENCY=$(echo "scale=1; 100 * $CACHE_READ_TOKENS / $TOTAL_CACHE_TOKENS" | bc)
  [[ "$CACHE_EFFICIENCY" == .* ]] && CACHE_EFFICIENCY="0$CACHE_EFFICIENCY"
fi

# Calculate cost per message
COST_PER_MESSAGE=0
if [ "$USER_MESSAGES" -gt 0 ]; then
  COST_PER_MESSAGE=$(echo "scale=2; $ESTIMATE_TOTAL_COST / $USER_MESSAGES" | bc)
  [[ "$COST_PER_MESSAGE" == .* ]] && COST_PER_MESSAGE="0$COST_PER_MESSAGE"
fi

# Calculate cache savings
CACHE_READ_COST_SAVED=0
for ((i=0; i<MODEL_COUNT; i++)); do
  MODEL_NAME=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].model")
  MODEL_CACHE_READ=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].cache_read")
  read INPUT_RATE OUTPUT_RATE CACHE_WRITE_MULT CACHE_READ_MULT < <(get_model_pricing "$MODEL_NAME")

  SAVED=$(echo "scale=2; ($MODEL_CACHE_READ * $INPUT_RATE * (1 - $CACHE_READ_MULT)) / 1000000" | bc)
  [[ "$SAVED" == .* ]] && SAVED="0$SAVED"
  CACHE_READ_COST_SAVED=$(echo "scale=2; $CACHE_READ_COST_SAVED + $SAVED" | bc)
  [[ "$CACHE_READ_COST_SAVED" == .* ]] && CACHE_READ_COST_SAVED="0$CACHE_READ_COST_SAVED"
done

# Get context growth
FIRST_INPUT=$(jq -s '[.[] | select(.message.usage.input_tokens)] | .[0].message.usage.input_tokens // 0' "$TRANSCRIPT_PATH")
LATEST_INPUT=$(jq -s '[.[] | select(.message.usage.input_tokens)] | .[-1].message.usage.input_tokens // 0' "$TRANSCRIPT_PATH")

# ============================================================================
# NOTE: /cost command cannot be executed programmatically
# ============================================================================
# The /cost command is a Claude Code slash command that cannot be executed
# from bash scripts. API users should run /cost separately to compare with
# these transcript-based estimates.
OFFICIAL_DATA=""

# ============================================================================
# GENERATE INSIGHTS & RECOMMENDATIONS
# ============================================================================

INSIGHTS=""
RECOMMENDATIONS=""

# Cache efficiency insights
if [ "$TOTAL_CACHE_TOKENS" -gt 0 ]; then
  if (( $(echo "$CACHE_EFFICIENCY >= 80" | bc -l) )); then
    INSIGHTS="${INSIGHTS}  âœ“ Excellent cache performance (${CACHE_EFFICIENCY}% hit rate saving ~\$${CACHE_READ_COST_SAVED})\n"
  elif (( $(echo "$CACHE_EFFICIENCY >= 50" | bc -l) )); then
    INSIGHTS="${INSIGHTS}  âœ“ Good cache performance (${CACHE_EFFICIENCY}% hit rate saving ~\$${CACHE_READ_COST_SAVED})\n"
    RECOMMENDATIONS="${RECOMMENDATIONS}  â€¢ Stay in session to maximize cache benefits\n"
  else
    INSIGHTS="${INSIGHTS}  âš ï¸ Low cache reuse (${CACHE_EFFICIENCY}% hit rate)\n"
    RECOMMENDATIONS="${RECOMMENDATIONS}  â€¢ Consider starting fresh session - cache may be stale\n"
  fi
fi

# Context growth insights
if [ "$FIRST_INPUT" -gt 0 ] && [ "$LATEST_INPUT" -gt 0 ]; then
  GROWTH_RATIO=$(echo "scale=1; $LATEST_INPUT / $FIRST_INPUT" | bc)
  [[ "$GROWTH_RATIO" == .* ]] && GROWTH_RATIO="0$GROWTH_RATIO"

  if (( $(echo "$GROWTH_RATIO >= 5" | bc -l) )); then
    GROWTH_PCT=$(echo "scale=0; (($LATEST_INPUT - $FIRST_INPUT) * 100) / $FIRST_INPUT" | bc)
    INSIGHTS="${INSIGHTS}  âš ï¸ Context grew significantly (${FIRST_INPUT} â†’ ${LATEST_INPUT} tokens, +${GROWTH_PCT}%)\n"
    RECOMMENDATIONS="${RECOMMENDATIONS}  â€¢ Use /clear to reset context - will improve speed and reduce cost\n"
  fi
fi

# Cost per message insights
if [ "$USER_MESSAGES" -gt 5 ] && (( $(echo "$COST_PER_MESSAGE > 0.50" | bc -l) )); then
  INSIGHTS="${INSIGHTS}  ğŸ’° High cost per message (\$${COST_PER_MESSAGE})\n"
  RECOMMENDATIONS="${RECOMMENDATIONS}  â€¢ Consider using Haiku for simpler tasks to reduce costs\n"
  RECOMMENDATIONS="${RECOMMENDATIONS}  â€¢ Ask more focused questions to reduce output token usage\n"
fi

# Tool usage pattern
if [ "$TOOL_CALLS" -gt 20 ] && [ "$USER_MESSAGES" -gt 0 ]; then
  TOOLS_PER_MSG=$(echo "scale=1; $TOOL_CALLS / $USER_MESSAGES" | bc)
  [[ "$TOOLS_PER_MSG" == .* ]] && TOOLS_PER_MSG="0$TOOLS_PER_MSG"
  INSIGHTS="${INSIGHTS}  ğŸ”§ High tool usage (${TOOLS_PER_MSG} tools per message)\n"
fi

# Default positive feedback if no issues
if [ -z "$INSIGHTS" ]; then
  INSIGHTS="  âœ“ Session efficiency looks good - no optimization needed\n"
fi

if [ -z "$RECOMMENDATIONS" ]; then
  RECOMMENDATIONS="  â€¢ Continue with current workflow\n"
fi

# Calculate trajectory
PROJECTED_NEXT_10="N/A"
if [ "$USER_MESSAGES" -gt 0 ]; then
  PROJECTED=$(echo "scale=2; $COST_PER_MESSAGE * 10" | bc)
  [[ "$PROJECTED" == .* ]] && PROJECTED="0$PROJECTED"
  PROJECTED_NEXT_10="~\$$PROJECTED"
fi

# ============================================================================
# OUTPUT DISPLAY - Adapt based on billing mode
# ============================================================================

echo ""
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘                          ğŸš— TRIP COMPUTER v0.4.0                            â•‘"
echo "â•‘                        Session Analytics Dashboard                          â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# ============================================================================
# USAGE SECTION - Different for API vs Subscription
# ============================================================================

# USAGE SECTION - Show transcript estimates for all users
if [ "$BILLING_MODE" = "Sub" ]; then
  USAGE_HEADER="ğŸ“Š SESSION USAGE ESTIMATE"
  USAGE_NOTE="  ğŸ“Œ Your usage is included in subscription - no charges."
  USAGE_NOTE2="     These API-equivalent estimates help you understand rate limit impact."
else
  USAGE_HEADER="ğŸ“Š SESSION USAGE ESTIMATE (API Billing)"
  USAGE_NOTE="  ğŸ’¡ Run /cost separately to see official billing data and compare accuracy."
  USAGE_NOTE2="     Estimates are typically within 10% of actual costs."
fi

echo "$USAGE_HEADER"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "  Messages: $USER_MESSAGES | Tools: $TOOL_CALLS | Cost: ~\$$ESTIMATE_TOTAL_COST"
echo "  Cache Efficiency: ${CACHE_EFFICIENCY}% | Tokens: $(printf "%'d" $TOTAL_TOKENS)"
echo ""
echo "  Token Breakdown:"
echo "    Input: $(printf "%'d" $INPUT_TOKENS) | Output: $(printf "%'d" $OUTPUT_TOKENS)"
echo "    Cache Writes: $(printf "%'d" $CACHE_CREATION_TOKENS) | Cache Reads: $(printf "%'d" $CACHE_READ_TOKENS)"
echo ""
echo "$USAGE_NOTE"
if [ -n "$USAGE_NOTE2" ]; then
  echo "$USAGE_NOTE2"
fi

echo ""

# ============================================================================
# INSIGHTS & RECOMMENDATIONS - Same for both billing modes
# ============================================================================

echo "ğŸ’¡ INSIGHTS & RECOMMENDATIONS"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo -e "$INSIGHTS"
if [ -n "$RECOMMENDATIONS" ]; then
  echo "  Smart actions:"
  echo -e "$RECOMMENDATIONS"
fi
echo ""

echo "ğŸ“ˆ TRAJECTORY"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "  At current rate (\$${COST_PER_MESSAGE}/msg):"
echo "    â€¢ Next 10 messages: $PROJECTED_NEXT_10"
if [ "$USER_MESSAGES" -gt 0 ]; then
  HOURLY_MSGS=$(echo "scale=0; 60 / ($USER_MESSAGES / 1)" | bc 2>/dev/null || echo "N/A")
  if [ "$HOURLY_MSGS" != "N/A" ] && [ "$HOURLY_MSGS" -gt 0 ]; then
    HOURLY_COST=$(echo "scale=2; $COST_PER_MESSAGE * $HOURLY_MSGS" | bc)
    [[ "$HOURLY_COST" == .* ]] && HOURLY_COST="0$HOURLY_COST"
    echo "    â€¢ Projected hourly rate: ~\$$HOURLY_COST at current pace"
  fi
fi
echo ""

echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""
echo "ğŸ“ Session: $SESSION_ID"
echo ""

exit 0
SCRIPT_EOF

chmod +x ~/.claude/hooks/show-session-stats.sh
echo "âœ“ Installed show-session-stats.sh (detailed stats)"

# Create slash command
cat > ~/.claude/commands/trip-computer.md << 'COMMAND_EOF'
---
description: Display trip computer analytics for the current session (rate, efficiency, cost drivers, recommendations)
---

Execute the session statistics script and display its output directly in your message text (not in a code block) so it's immediately visible without requiring expansion:

1. Run: ~/.claude/hooks/show-session-stats.sh
2. Capture the output
3. Display the full output as plain text in your response
4. Do not add any commentary, analysis, or interpretation - just show the trip computer output
COMMAND_EOF

echo "âœ“ Created /trip-computer command"
echo ""

echo "Configuring status line..."

# Configure settings.json
SETTINGS_FILE="$HOME/.claude/settings.json"

if [ -f "$SETTINGS_FILE" ]; then
  # Backup existing settings
  cp "$SETTINGS_FILE" "${SETTINGS_FILE}.backup"
  echo "âœ“ Backed up existing settings to settings.json.backup"

  # Update statusLine using jq
  jq '.statusLine = {"type": "command", "command": "~/.claude/hooks/brief-stats.sh"}' \
    "$SETTINGS_FILE" > "${SETTINGS_FILE}.tmp" && mv "${SETTINGS_FILE}.tmp" "$SETTINGS_FILE"
  echo "âœ“ Updated ~/.claude/settings.json"
else
  # Create new settings file
  cat > "$SETTINGS_FILE" << 'SETTINGS_EOF'
{
  "statusLine": {
    "type": "command",
    "command": "~/.claude/hooks/brief-stats.sh"
  }
}
SETTINGS_EOF
  echo "âœ“ Created ~/.claude/settings.json"
fi

echo ""
echo "Testing installation..."

# Test brief-stats.sh
BRIEF_OUTPUT=$(~/.claude/hooks/brief-stats.sh 2>&1)
if [ $? -eq 0 ]; then
  echo "âœ“ Status line script works: $BRIEF_OUTPUT"
else
  echo "âš ï¸  Status line script error (may be normal if no sessions exist yet)"
fi

# Test show-session-stats.sh
DETAIL_OUTPUT=$(~/.claude/hooks/show-session-stats.sh 2>&1 | head -3)
if [ $? -eq 0 ]; then
  echo "âœ“ Detailed stats script works"
else
  echo "âš ï¸  Detailed stats script error (may be normal if no sessions exist yet)"
fi

echo ""
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘                  Installation Complete! âœ“                  â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
echo "What's installed:"
echo "  â€¢ Status line hook:  ~/.claude/hooks/brief-stats.sh"
echo "  â€¢ Detailed stats:    ~/.claude/hooks/show-session-stats.sh"
echo "  â€¢ Slash command:     /trip-computer"
echo "  â€¢ Configuration:     ~/.claude/settings.json"
echo "  â€¢ Billing config:    ~/.claude/hooks/.stats-config"
echo ""
echo "Next steps:"
echo "  1. Restart Claude Code to see the status line"
echo "  2. Type /trip-computer to view detailed analytics"
echo "  3. Check the status bar at the bottom of Claude Code"
echo ""
echo "What you'll see in the status line:"
echo "  ğŸ’¬ X msgs | ğŸ”§ X tools | ğŸ¯ XK tok | ğŸ’³ API ~\$X.XX"
echo "  or"
echo "  ğŸ’¬ X msgs | ğŸ”§ X tools | ğŸ¯ XK tok | ğŸ“… Sub ~\$X.XX"
echo ""
echo "Features:"
echo "  âœ“ User-configured billing mode ($BILLING_MODE)"
echo "  âœ“ Model-specific pricing (Opus, Sonnet, Haiku)"
echo "  âœ“ Agent activity indicator"
echo "  âœ“ Accurate token deduplication"
echo "  âœ“ Session-level cost tracking"
echo ""
echo "Enjoy your new stats tracking! ğŸš€"
