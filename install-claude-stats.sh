#!/bin/bash
set -e

# Claude Code Session Stats Tracking - Automated Installer
# Supports: Linux, macOS, Windows (WSL/Git Bash)

# Read version from VERSION file
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VERSION="0.0.1"
if [ -f "$SCRIPT_DIR/VERSION" ]; then
  VERSION=$(cat "$SCRIPT_DIR/VERSION" | tr -d '[:space:]')
fi

echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
echo "‚ïë   Claude Code Session Stats Tracking - Installer          ‚ïë"
echo "‚ïë   Version: $VERSION                                        ‚ïë"
echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
echo ""

# Detect operating system
OS="unknown"
if [[ "$OSTYPE" == "linux-gnu"* ]]; then
  OS="linux"
elif [[ "$OSTYPE" == "darwin"* ]]; then
  OS="macos"
elif [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]] || [[ "$OSTYPE" == "win32" ]]; then
  OS="windows"
else
  # Check for WSL
  if grep -qi microsoft /proc/version 2>/dev/null; then
    OS="linux"
  fi
fi

echo "‚úì Detected OS: $OS"
echo ""

# Check prerequisites
echo "Checking prerequisites..."

# Check for jq
if ! command -v jq &> /dev/null; then
  echo "‚ùå jq is not installed"
  echo ""
  echo "Please install jq first:"
  case "$OS" in
    linux)
      echo "  Ubuntu/Debian: sudo apt-get install -y jq"
      echo "  RHEL/Fedora:   sudo dnf install -y jq"
      echo "  Arch:          sudo pacman -S jq"
      ;;
    macos)
      echo "  macOS:         brew install jq"
      ;;
    windows)
      echo "  WSL:           sudo apt-get install -y jq"
      echo "  Git Bash:      Download from https://stedolan.github.io/jq/"
      ;;
  esac
  exit 1
fi
echo "‚úì jq is installed ($(jq --version))"

# Check for bc
if ! command -v bc &> /dev/null; then
  echo "‚ùå bc is not installed"
  echo ""
  echo "Please install bc first:"
  case "$OS" in
    linux)
      echo "  Ubuntu/Debian: sudo apt-get install -y bc"
      echo "  RHEL/Fedora:   sudo dnf install -y bc"
      ;;
    macos)
      echo "  bc is pre-installed on macOS"
      ;;
    windows)
      echo "  bc is usually included with Git Bash"
      ;;
  esac
  exit 1
fi
echo "‚úì bc is installed"

echo ""
echo "Configuring billing mode..."
echo ""
echo "Which billing mode are you using?"
echo "  1) API Billing (pay-per-use, charged per API call)"
echo "  2) Subscription Plan (monthly subscription with included usage)"
echo ""

# Read user input with validation
while true; do
  read -p "Enter your choice (1 or 2): " BILLING_CHOICE
  case "$BILLING_CHOICE" in
    1)
      BILLING_MODE="API"
      BILLING_ICON="üí≥"
      echo "‚úì Selected: API Billing"
      break
      ;;
    2)
      BILLING_MODE="Sub"
      BILLING_ICON="üìÖ"
      echo "‚úì Selected: Subscription Plan"
      break
      ;;
    *)
      echo "‚ùå Invalid choice. Please enter 1 or 2."
      ;;
  esac
done

echo ""
echo "Creating directories..."

# Create directories
mkdir -p ~/.claude/hooks
mkdir -p ~/.claude/commands

echo "‚úì Created ~/.claude/hooks"
echo "‚úì Created ~/.claude/commands"

# Save billing mode configuration
cat > ~/.claude/hooks/.stats-config << CONFIG_EOF
# Claude Code Session Stats Configuration
# Generated by install-claude-stats.sh
BILLING_MODE="$BILLING_MODE"
BILLING_ICON="$BILLING_ICON"
CONFIG_EOF

echo "‚úì Saved billing configuration to ~/.claude/hooks/.stats-config"
echo ""

echo "Installing scripts..."

# Create brief-stats.sh (status line)
cat > ~/.claude/hooks/brief-stats.sh << 'SCRIPT_EOF'
#!/bin/bash
# Brief session statistics displayed in the status line
# Claude Code Session Stats - Version 0.6.2

# Force C locale for consistent number formatting
export LC_NUMERIC=C

# Try to read session info from stdin (provided by Claude Code in statusLine context)
# Read with a 1 second timeout - if nothing arrives, assume no session
if IFS= read -t 1 -r INPUT; then
  # If we got one line, try to read the rest (for multi-line JSON)
  while IFS= read -t 1 -r line; do
    INPUT="${INPUT}${line}"
  done
else
  INPUT=""
fi

# Extract session ID from JSON input if available
ACTIVE_SESSION_ID=$(echo "$INPUT" | jq -r '.sessionId // empty' 2>/dev/null)

# Find the project directory
# Find the project directory - handle Windows drive letters specially
# Get working directory from Claude Code JSON input, fallback to pwd
if [ -n "$INPUT" ]; then
  PWD_PATH=$(echo "$INPUT" | jq -r '.workspace.current_dir // .workspace.project_dir // .cwd // empty' 2>/dev/null)
fi
if [ -z "$PWD_PATH" ]; then
  PWD_PATH=$(pwd)
fi
if [[ "$PWD_PATH" =~ ^/([a-z])/ ]]; then
  # Windows Git Bash path like /c/Dev/project -> C--Dev-project
  DRIVE_LETTER=$(echo "${BASH_REMATCH[1]}" | tr '[:lower:]' '[:upper:]')
  REST_PATH=$(echo "$PWD_PATH" | sed 's|^/[a-z]/||' | sed 's/\//-/g' | sed 's/_/-/g')
  PROJECT_DIR="${DRIVE_LETTER}--${REST_PATH}"
else
  # Unix path - replace / and _ with -
  PROJECT_DIR=$(echo "$PWD_PATH" | sed 's/\//-/g' | sed 's/_/-/g')
fi
TRANSCRIPT_DIR="$HOME/.claude/projects/$PROJECT_DIR"

# Check for active sub-agents with robust detection
if [ -d "$TRANSCRIPT_DIR" ]; then
  NOW=$(date +%s)
  ACTIVE_AGENTS=0

  # Iterate through agent files if they exist
  for agent_file in "$TRANSCRIPT_DIR"/agent-*.jsonl; do
    # Check if file exists (glob may not match anything)
    if [ -f "$agent_file" ]; then
      # Get file modification time (Linux uses -c, macOS uses -f)
      FILE_MTIME=$(stat -c %Y "$agent_file" 2>/dev/null || stat -f %m "$agent_file" 2>/dev/null || echo 0)
      AGE=$((NOW - FILE_MTIME))

      # Multi-criteria check for active agents:
      # 1. File modified in last 3 seconds (stricter window to avoid false positives from old sessions)
      # 2. File size > 100 bytes (not just init/empty file)
      # 3. File is actively growing (check size twice with small delay)
      if [ "$AGE" -lt 3 ]; then
        # Get file size (Linux uses -c %s, macOS uses -f %z)
        FILE_SIZE_1=$(stat -c %s "$agent_file" 2>/dev/null || stat -f %z "$agent_file" 2>/dev/null || echo 0)

        # Check if file has meaningful content (> 100 bytes)
        if [ "$FILE_SIZE_1" -gt 100 ]; then
          # Wait briefly and check if file is still growing (active write)
          sleep 0.1
          FILE_SIZE_2=$(stat -c %s "$agent_file" 2>/dev/null || stat -f %z "$agent_file" 2>/dev/null || echo 0)

          # If file grew, it's actively being written to
          if [ "$FILE_SIZE_2" -gt "$FILE_SIZE_1" ]; then
            ACTIVE_AGENTS=1
            break
          fi
        fi
      fi
    fi
  done

  if [ "$ACTIVE_AGENTS" -eq 1 ]; then
    echo "ü§ñ Sub-agents running, stand by..."
    exit 0
  fi
fi

# Load billing mode from config file (needed for zeroed stats display)
CONFIG_FILE="$HOME/.claude/hooks/.stats-config"
if [ -f "$CONFIG_FILE" ]; then
  source "$CONFIG_FILE"
else
  # Fallback to defaults if config doesn't exist
  BILLING_MODE="API"
  BILLING_ICON="üí≥"
fi

# If we have an active session ID, use it directly
if [ -n "$ACTIVE_SESSION_ID" ]; then
  TRANSCRIPT_PATH="$TRANSCRIPT_DIR/${ACTIVE_SESSION_ID}.jsonl"

  # If the transcript doesn't exist yet (new session), show zeroed stats
  if [ ! -f "$TRANSCRIPT_PATH" ]; then
    echo "üí¨ 0 msgs | üîß 0 tools | üéØ 0 tok | ‚ö° 0% eff | $BILLING_ICON ~\$0.0000 (\$0.00/msg) | üìä /trip-computer"
    exit 0
  fi
else
  # No active session ID - fall back to most recent transcript
  if [ -d "$TRANSCRIPT_DIR" ]; then
    TRANSCRIPT_PATH=$(ls -t "$TRANSCRIPT_DIR"/*.jsonl 2>/dev/null | grep -v agent | head -1)
    if [ -z "$TRANSCRIPT_PATH" ]; then
      # No transcripts exist - show zeroed stats
      echo "üí¨ 0 msgs | üîß 0 tools | üéØ 0 tok | ‚ö° 0% eff | $BILLING_ICON ~\$0.0000 (\$0.00/msg) | üìä /trip-computer"
      exit 0
    fi
  else
    # New directory - show zeroed stats
    echo "üí¨ 0 msgs | üîß 0 tools | üéØ 0 tok | ‚ö° 0% eff | $BILLING_ICON ~\$0.0000 (\$0.00/msg) | üìä /trip-computer"
    exit 0
  fi
fi

# Calculate statistics from current session only
# Count messages and tool calls from current transcript
# Count only direct user prompts (exclude tool results, meta messages, and command messages)
USER_MESSAGES=$(jq -s '[.[] | select(.type == "user" and (.isMeta != true) and (.message.content | if type == "array" then all(.[]; .type != "tool_result") else (test("<command-name>|<command-args>|<local-command-stdout>|<command-message>") | not) end))] | length' "$TRANSCRIPT_PATH" 2>/dev/null || echo "0")

# Count tool uses - they are nested inside message.content arrays
TOOL_CALLS=$(jq -s '[.[] | select(.type == "assistant") | .message.content[]? | select(.type == "tool_use")] | length' "$TRANSCRIPT_PATH" 2>/dev/null || echo "0")

# Parse current transcript and group by requestId + model
PER_MODEL_DATA=$(jq -s '
[.[] | select(.message.usage and .message.model)] |
group_by(.requestId + "|" + .message.model) |
map({
  requestId: .[0].requestId,
  model: .[0].message.model,
  input: (map(.message.usage.input_tokens // 0) | max),
  output: (map(.message.usage.output_tokens // 0) | max),
  cache_creation: (map(.message.usage.cache_creation_input_tokens // 0) | max),
  cache_read: (map(.message.usage.cache_read_input_tokens // 0) | max)
}) |
group_by(.model) |
map({
  model: .[0].model,
  input: (map(.input) | add),
  output: (map(.output) | add),
  cache_creation: (map(.cache_creation) | add),
  cache_read: (map(.cache_read) | add)
})
' "$TRANSCRIPT_PATH" 2>/dev/null || echo '[]')

# Calculate totals across all models
INPUT_TOKENS=$(echo "$PER_MODEL_DATA" | jq '[.[].input] | add // 0')
OUTPUT_TOKENS=$(echo "$PER_MODEL_DATA" | jq '[.[].output] | add // 0')
CACHE_CREATION_TOKENS=$(echo "$PER_MODEL_DATA" | jq '[.[].cache_creation] | add // 0')
CACHE_READ_TOKENS=$(echo "$PER_MODEL_DATA" | jq '[.[].cache_read] | add // 0')

# Calculate total tokens
TOTAL_TOKENS=$((INPUT_TOKENS + OUTPUT_TOKENS + CACHE_CREATION_TOKENS + CACHE_READ_TOKENS))

# Format tokens in industry standard abbreviation (K for thousands, M for millions)
if [ $TOTAL_TOKENS -ge 1000000 ]; then
  # Millions
  FORMATTED_TOKENS=$(echo "scale=1; $TOTAL_TOKENS / 1000000" | bc 2>/dev/null || echo "0")
  # Handle bc output starting with .
  if [[ "$FORMATTED_TOKENS" == .* ]]; then
    FORMATTED_TOKENS="0$FORMATTED_TOKENS"
  fi
  FORMATTED_TOKENS="${FORMATTED_TOKENS}M"
elif [ $TOTAL_TOKENS -ge 1000 ]; then
  # Thousands
  FORMATTED_TOKENS=$(echo "scale=1; $TOTAL_TOKENS / 1000" | bc 2>/dev/null || echo "0")
  if [[ "$FORMATTED_TOKENS" == .* ]]; then
    FORMATTED_TOKENS="0$FORMATTED_TOKENS"
  fi
  FORMATTED_TOKENS="${FORMATTED_TOKENS}K"
else
  # Less than 1000
  FORMATTED_TOKENS="$TOTAL_TOKENS"
fi

# Helper function to get pricing for a model
get_model_pricing() {
  local model_name="$1"
  local input_rate output_rate cache_write_mult cache_read_mult

  if [[ "$model_name" == *"opus-4-5"* ]] || [[ "$model_name" == *"opus-4.5"* ]]; then
    input_rate=5; output_rate=25; cache_write_mult=1.25; cache_read_mult=0.10
  elif [[ "$model_name" == *"opus-4"* ]] || [[ "$model_name" == *"opus-3"* ]] || [[ "$model_name" == *"opus"* ]]; then
    input_rate=15; output_rate=75; cache_write_mult=1.25; cache_read_mult=0.10
  elif [[ "$model_name" == *"haiku-4-5"* ]] || [[ "$model_name" == *"haiku-4.5"* ]]; then
    input_rate=1; output_rate=5; cache_write_mult=1.25; cache_read_mult=0.10
  elif [[ "$model_name" == *"haiku-3-5"* ]] || [[ "$model_name" == *"haiku-3.5"* ]]; then
    input_rate=0.80; output_rate=4; cache_write_mult=1.25; cache_read_mult=0.10
  elif [[ "$model_name" == *"haiku-3"* ]] || [[ "$model_name" == *"haiku"* ]]; then
    input_rate=0.25; output_rate=1.25; cache_write_mult=1.20; cache_read_mult=0.12
  else
    input_rate=3; output_rate=15; cache_write_mult=1.25; cache_read_mult=0.10
  fi

  echo "$input_rate $output_rate $cache_write_mult $cache_read_mult"
}

# Calculate costs per model and sum
TOTAL_COST=0
MODEL_COUNT=$(echo "$PER_MODEL_DATA" | jq 'length')
for ((i=0; i<MODEL_COUNT; i++)); do
  MODEL_NAME=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].model")
  MODEL_INPUT=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].input")
  MODEL_OUTPUT=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].output")
  MODEL_CACHE_WRITE=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].cache_creation")
  MODEL_CACHE_READ=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].cache_read")

  read INPUT_RATE OUTPUT_RATE CACHE_WRITE_MULT CACHE_READ_MULT < <(get_model_pricing "$MODEL_NAME")

  MODEL_COST=$(echo "scale=4; \
    ($MODEL_INPUT * $INPUT_RATE / 1000000) + \
    ($MODEL_OUTPUT * $OUTPUT_RATE / 1000000) + \
    ($MODEL_CACHE_WRITE * $INPUT_RATE * $CACHE_WRITE_MULT / 1000000) + \
    ($MODEL_CACHE_READ * $INPUT_RATE * $CACHE_READ_MULT / 1000000)" | bc 2>/dev/null || echo "0")

  [[ "$MODEL_COST" == .* ]] && MODEL_COST="0$MODEL_COST"
  TOTAL_COST=$(echo "scale=4; $TOTAL_COST + $MODEL_COST" | bc 2>/dev/null || echo "0")
  [[ "$TOTAL_COST" == .* ]] && TOTAL_COST="0$TOTAL_COST"
done

# Format cost - handle bc output that starts with . (like .8809 -> 0.8809)
if [[ "$TOTAL_COST" == .* ]]; then
  TOTAL_COST="0$TOTAL_COST"
fi
FORMATTED_COST=$(printf "%.4f" "$TOTAL_COST" 2>/dev/null || echo "0.0000")

# Calculate cost per message for trajectory indicator
COST_PER_MESSAGE="0.00"
if [ "$USER_MESSAGES" -gt 0 ]; then
  COST_PER_MESSAGE=$(echo "scale=2; $TOTAL_COST / $USER_MESSAGES" | bc 2>/dev/null || echo "0.00")
  [[ "$COST_PER_MESSAGE" == .* ]] && COST_PER_MESSAGE="0$COST_PER_MESSAGE"
fi

# Calculate cache efficiency percentage
TOTAL_CACHE_TOKENS=$((CACHE_CREATION_TOKENS + CACHE_READ_TOKENS))
CACHE_EFFICIENCY="0"
if [ "$TOTAL_CACHE_TOKENS" -gt 0 ]; then
  CACHE_EFFICIENCY=$(echo "scale=0; 100 * $CACHE_READ_TOKENS / $TOTAL_CACHE_TOKENS" | bc 2>/dev/null || echo "0")
  [[ "$CACHE_EFFICIENCY" == .* ]] && CACHE_EFFICIENCY="0"
fi

# Output brief stats (single line for status bar) with billing mode indicator, cache efficiency, cost per message, and trip computer pointer
# Format: msgs | tools | tokens | cache eff | cost (cost/msg) | trip computer pointer
echo "üí¨ $USER_MESSAGES msgs | üîß $TOOL_CALLS tools | üéØ ${FORMATTED_TOKENS} tok | ‚ö° ${CACHE_EFFICIENCY}% eff | $BILLING_ICON ~\$$FORMATTED_COST (\$$COST_PER_MESSAGE/msg) | üìä /trip-computer"

exit 0
SCRIPT_EOF

chmod +x ~/.claude/hooks/brief-stats.sh
echo "‚úì Installed brief-stats.sh (status line)"

# Create show-session-stats.sh (detailed stats - enhanced "trip computer" version)
cat > ~/.claude/hooks/show-session-stats.sh << 'SCRIPT_EOF'
#!/bin/bash
set -e

# Helper script to display session statistics for current or specified session
# Claude Code Session Stats - Version 0.6.2
# Usage: ./show-session-stats.sh [session_id]

# Force C locale for consistent number formatting (avoids locale warnings on systems without en_US.UTF-8)
export LC_NUMERIC=C

# If session_id provided, use it; otherwise find the most recent session
if [ -n "$1" ]; then
  SESSION_ID="$1"
else
  # Find the most recent transcript file for this project
  PROJECT_DIR=$(pwd | sed 's|^/\([a-z]\)/|\U\1--|' | sed 's/\//-/g' | sed 's/_/-/g')
  TRANSCRIPT_DIR="$HOME/.claude/projects/$PROJECT_DIR"

  if [ -d "$TRANSCRIPT_DIR" ]; then
    TRANSCRIPT_PATH=$(ls -t "$TRANSCRIPT_DIR"/*.jsonl 2>/dev/null | grep -v agent | head -1)
    if [ -z "$TRANSCRIPT_PATH" ]; then
      echo "‚ùå No session transcripts found in $TRANSCRIPT_DIR"
      exit 1
    fi
    SESSION_ID=$(basename "$TRANSCRIPT_PATH" .jsonl)
  else
    echo "‚ùå No transcript directory found for this project"
    exit 1
  fi
fi

# Construct transcript path
PROJECT_DIR=$(pwd | sed 's|^/\([a-z]\)/|\U\1--|' | sed 's/\//-/g' | sed 's/_/-/g')
TRANSCRIPT_PATH="$HOME/.claude/projects/$PROJECT_DIR/${SESSION_ID}.jsonl"

if [ ! -f "$TRANSCRIPT_PATH" ]; then
  echo "‚ùå Transcript file not found: $TRANSCRIPT_PATH"
  exit 1
fi

# Load billing mode from config file
CONFIG_FILE="$HOME/.claude/hooks/.stats-config"
BILLING_MODE="API"
BILLING_ICON="üí≥"
if [ -f "$CONFIG_FILE" ]; then
  source "$CONFIG_FILE"
fi

# ============================================================================
# TRANSCRIPT ANALYSIS - Calculate estimates from session transcript
# ============================================================================

# Count messages and tool calls from current transcript
USER_MESSAGES=$(jq -s '[.[] | select(.type == "user" and (.isMeta != true) and (.message.content | if type == "array" then all(.[]; .type != "tool_result") else (test("<command-name>|<command-args>|<local-command-stdout>|<command-message>") | not) end))] | length' "$TRANSCRIPT_PATH")

TOOL_CALLS=$(jq -s '[.[] | select(.type == "assistant") | .message.content[]? | select(.type == "tool_use")] | length' "$TRANSCRIPT_PATH")

# Parse transcript and group by requestId + model to avoid double-counting
PER_MODEL_DATA=$(jq -s '
[.[] | select(.message.usage and .message.model)] |
group_by(.requestId + "|" + .message.model) |
map({
  requestId: .[0].requestId,
  model: .[0].message.model,
  input: (map(.message.usage.input_tokens // 0) | max),
  output: (map(.message.usage.output_tokens // 0) | max),
  cache_creation: (map(.message.usage.cache_creation_input_tokens // 0) | max),
  cache_read: (map(.message.usage.cache_read_input_tokens // 0) | max)
}) |
group_by(.model) |
map({
  model: .[0].model,
  requests: length,
  input: (map(.input) | add),
  output: (map(.output) | add),
  cache_creation: (map(.cache_creation) | add),
  cache_read: (map(.cache_read) | add)
})
' "$TRANSCRIPT_PATH" 2>/dev/null || echo '[]')

# Calculate totals
INPUT_TOKENS=$(echo "$PER_MODEL_DATA" | jq '[.[].input] | add // 0')
OUTPUT_TOKENS=$(echo "$PER_MODEL_DATA" | jq '[.[].output] | add // 0')
CACHE_CREATION_TOKENS=$(echo "$PER_MODEL_DATA" | jq '[.[].cache_creation] | add // 0')
CACHE_READ_TOKENS=$(echo "$PER_MODEL_DATA" | jq '[.[].cache_read] | add // 0')
TOTAL_TOKENS=$((INPUT_TOKENS + OUTPUT_TOKENS + CACHE_CREATION_TOKENS + CACHE_READ_TOKENS))

# Helper function to get pricing for a model
get_model_pricing() {
  local model_name="$1"
  local input_rate output_rate cache_write_mult cache_read_mult

  if [[ "$model_name" == *"opus-4-5"* ]] || [[ "$model_name" == *"opus-4.5"* ]]; then
    input_rate=5; output_rate=25; cache_write_mult=1.25; cache_read_mult=0.10
  elif [[ "$model_name" == *"opus-4"* ]] || [[ "$model_name" == *"opus-3"* ]] || [[ "$model_name" == *"opus"* ]]; then
    input_rate=15; output_rate=75; cache_write_mult=1.25; cache_read_mult=0.10
  elif [[ "$model_name" == *"haiku-4-5"* ]] || [[ "$model_name" == *"haiku-4.5"* ]]; then
    input_rate=1; output_rate=5; cache_write_mult=1.25; cache_read_mult=0.10
  elif [[ "$model_name" == *"haiku-3-5"* ]] || [[ "$model_name" == *"haiku-3.5"* ]]; then
    input_rate=0.80; output_rate=4; cache_write_mult=1.25; cache_read_mult=0.10
  elif [[ "$model_name" == *"haiku-3"* ]] || [[ "$model_name" == *"haiku"* ]]; then
    input_rate=0.25; output_rate=1.25; cache_write_mult=1.20; cache_read_mult=0.12
  else
    input_rate=3; output_rate=15; cache_write_mult=1.25; cache_read_mult=0.10
  fi

  echo "$input_rate $output_rate $cache_write_mult $cache_read_mult"
}

# Helper function to get friendly model name
get_friendly_model_name() {
  local model_name="$1"
  if [[ "$model_name" == *"opus-4-5"* ]] || [[ "$model_name" == *"opus-4.5"* ]]; then
    echo "Opus 4.5"
  elif [[ "$model_name" == *"opus-4"* ]]; then
    echo "Opus 4"
  elif [[ "$model_name" == *"opus-3"* ]]; then
    echo "Opus 3"
  elif [[ "$model_name" == *"haiku-4-5"* ]] || [[ "$model_name" == *"haiku-4.5"* ]]; then
    echo "Haiku 4.5"
  elif [[ "$model_name" == *"haiku-3-5"* ]] || [[ "$model_name" == *"haiku-3.5"* ]]; then
    echo "Haiku 3.5"
  elif [[ "$model_name" == *"haiku-3"* ]]; then
    echo "Haiku 3"
  elif [[ "$model_name" == *"sonnet"* ]]; then
    echo "Sonnet 4.5"
  else
    echo "Unknown"
  fi
}

# Calculate estimated costs per model and per cost driver
ESTIMATE_TOTAL_COST=0
TOTAL_INPUT_COST=0
TOTAL_OUTPUT_COST=0
TOTAL_CACHE_WRITE_COST=0
TOTAL_CACHE_READ_COST=0

declare -a MODEL_NAMES
declare -a MODEL_COSTS
declare -a MODEL_REQUESTS

MODEL_COUNT=$(echo "$PER_MODEL_DATA" | jq 'length')
for ((i=0; i<MODEL_COUNT; i++)); do
  MODEL_NAME=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].model")
  MODEL_INPUT=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].input")
  MODEL_OUTPUT=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].output")
  MODEL_CACHE_WRITE=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].cache_creation")
  MODEL_CACHE_READ=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].cache_read")
  MODEL_REQUEST_COUNT=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].requests")

  read INPUT_RATE OUTPUT_RATE CACHE_WRITE_MULT CACHE_READ_MULT < <(get_model_pricing "$MODEL_NAME")

  # Calculate individual cost components
  INPUT_COST=$(echo "scale=4; $MODEL_INPUT * $INPUT_RATE / 1000000" | bc)
  OUTPUT_COST=$(echo "scale=4; $MODEL_OUTPUT * $OUTPUT_RATE / 1000000" | bc)
  CACHE_WRITE_COST=$(echo "scale=4; $MODEL_CACHE_WRITE * $INPUT_RATE * $CACHE_WRITE_MULT / 1000000" | bc)
  CACHE_READ_COST=$(echo "scale=4; $MODEL_CACHE_READ * $INPUT_RATE * $CACHE_READ_MULT / 1000000" | bc)

  # Fix leading dot
  [[ "$INPUT_COST" == .* ]] && INPUT_COST="0$INPUT_COST"
  [[ "$OUTPUT_COST" == .* ]] && OUTPUT_COST="0$OUTPUT_COST"
  [[ "$CACHE_WRITE_COST" == .* ]] && CACHE_WRITE_COST="0$CACHE_WRITE_COST"
  [[ "$CACHE_READ_COST" == .* ]] && CACHE_READ_COST="0$CACHE_READ_COST"

  # Accumulate totals
  TOTAL_INPUT_COST=$(echo "scale=4; $TOTAL_INPUT_COST + $INPUT_COST" | bc)
  TOTAL_OUTPUT_COST=$(echo "scale=4; $TOTAL_OUTPUT_COST + $OUTPUT_COST" | bc)
  TOTAL_CACHE_WRITE_COST=$(echo "scale=4; $TOTAL_CACHE_WRITE_COST + $CACHE_WRITE_COST" | bc)
  TOTAL_CACHE_READ_COST=$(echo "scale=4; $TOTAL_CACHE_READ_COST + $CACHE_READ_COST" | bc)

  [[ "$TOTAL_INPUT_COST" == .* ]] && TOTAL_INPUT_COST="0$TOTAL_INPUT_COST"
  [[ "$TOTAL_OUTPUT_COST" == .* ]] && TOTAL_OUTPUT_COST="0$TOTAL_OUTPUT_COST"
  [[ "$TOTAL_CACHE_WRITE_COST" == .* ]] && TOTAL_CACHE_WRITE_COST="0$TOTAL_CACHE_WRITE_COST"
  [[ "$TOTAL_CACHE_READ_COST" == .* ]] && TOTAL_CACHE_READ_COST="0$TOTAL_CACHE_READ_COST"

  MODEL_COST=$(echo "scale=4; $INPUT_COST + $OUTPUT_COST + $CACHE_WRITE_COST + $CACHE_READ_COST" | bc)
  [[ "$MODEL_COST" == .* ]] && MODEL_COST="0$MODEL_COST"

  ESTIMATE_TOTAL_COST=$(echo "scale=4; $ESTIMATE_TOTAL_COST + $MODEL_COST" | bc)
  [[ "$ESTIMATE_TOTAL_COST" == .* ]] && ESTIMATE_TOTAL_COST="0$ESTIMATE_TOTAL_COST"

  # Store for model mix section
  MODEL_NAMES[$i]=$(get_friendly_model_name "$MODEL_NAME")
  MODEL_COSTS[$i]=$MODEL_COST
  MODEL_REQUESTS[$i]=$MODEL_REQUEST_COUNT
done

# Calculate cache efficiency
TOTAL_CACHE_TOKENS=$((CACHE_CREATION_TOKENS + CACHE_READ_TOKENS))
CACHE_EFFICIENCY=0
if [ "$TOTAL_CACHE_TOKENS" -gt 0 ]; then
  CACHE_EFFICIENCY=$(echo "scale=1; 100 * $CACHE_READ_TOKENS / $TOTAL_CACHE_TOKENS" | bc)
  [[ "$CACHE_EFFICIENCY" == .* ]] && CACHE_EFFICIENCY="0$CACHE_EFFICIENCY"
fi

# Calculate cost per message
COST_PER_MESSAGE=0
if [ "$USER_MESSAGES" -gt 0 ]; then
  COST_PER_MESSAGE=$(echo "scale=2; $ESTIMATE_TOTAL_COST / $USER_MESSAGES" | bc)
  [[ "$COST_PER_MESSAGE" == .* ]] && COST_PER_MESSAGE="0$COST_PER_MESSAGE"
fi

# Calculate cache savings
CACHE_READ_COST_SAVED=0
for ((i=0; i<MODEL_COUNT; i++)); do
  MODEL_NAME=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].model")
  MODEL_CACHE_READ=$(echo "$PER_MODEL_DATA" | jq -r ".[$i].cache_read")
  read INPUT_RATE OUTPUT_RATE CACHE_WRITE_MULT CACHE_READ_MULT < <(get_model_pricing "$MODEL_NAME")

  SAVED=$(echo "scale=2; ($MODEL_CACHE_READ * $INPUT_RATE * (1 - $CACHE_READ_MULT)) / 1000000" | bc)
  [[ "$SAVED" == .* ]] && SAVED="0$SAVED"
  CACHE_READ_COST_SAVED=$(echo "scale=2; $CACHE_READ_COST_SAVED + $SAVED" | bc)
  [[ "$CACHE_READ_COST_SAVED" == .* ]] && CACHE_READ_COST_SAVED="0$CACHE_READ_COST_SAVED"
done

# Get context growth
FIRST_INPUT=$(jq -s '[.[] | select(.message.usage.input_tokens)] | .[0].message.usage.input_tokens // 0' "$TRANSCRIPT_PATH")
LATEST_INPUT=$(jq -s '[.[] | select(.message.usage.input_tokens)] | .[-1].message.usage.input_tokens // 0' "$TRANSCRIPT_PATH")

# Calculate efficiency metrics
OUTPUT_INPUT_RATIO=0
COST_PER_TOKEN=0
if [ "$INPUT_TOKENS" -gt 0 ]; then
  OUTPUT_INPUT_RATIO=$(echo "scale=1; $OUTPUT_TOKENS / $INPUT_TOKENS" | bc)
  [[ "$OUTPUT_INPUT_RATIO" == .* ]] && OUTPUT_INPUT_RATIO="0$OUTPUT_INPUT_RATIO"
fi
if [ "$TOTAL_TOKENS" -gt 0 ]; then
  COST_PER_TOKEN=$(echo "scale=8; $ESTIMATE_TOTAL_COST / $TOTAL_TOKENS" | bc)
  [[ "$COST_PER_TOKEN" == .* ]] && COST_PER_TOKEN="0$COST_PER_TOKEN"
fi

# ============================================================================
# SESSION HEALTH SCORE CALCULATION (0-100)
# ============================================================================

HEALTH_SCORE=0
HEALTH_REASONS=()

# Cache efficiency component (0-40 points)
if [ "$TOTAL_CACHE_TOKENS" -gt 0 ]; then
  if (( $(echo "$CACHE_EFFICIENCY >= 80" | bc -l) )); then
    HEALTH_SCORE=$((HEALTH_SCORE + 40))
    HEALTH_REASONS+=("‚úÖ Excellent cache efficiency")
  elif (( $(echo "$CACHE_EFFICIENCY >= 50" | bc -l) )); then
    HEALTH_SCORE=$((HEALTH_SCORE + 30))
    HEALTH_REASONS+=("‚úÖ Good cache efficiency")
  elif (( $(echo "$CACHE_EFFICIENCY >= 20" | bc -l) )); then
    HEALTH_SCORE=$((HEALTH_SCORE + 15))
    HEALTH_REASONS+=("‚ö†Ô∏è  Moderate cache efficiency")
  else
    HEALTH_SCORE=$((HEALTH_SCORE + 5))
    HEALTH_REASONS+=("‚ö†Ô∏è  Low cache efficiency")
  fi
else
  HEALTH_SCORE=$((HEALTH_SCORE + 20))
  HEALTH_REASONS+=("‚û°Ô∏è  No cache usage yet")
fi

# Cost per message component (0-30 points)
if [ "$USER_MESSAGES" -gt 0 ]; then
  if (( $(echo "$COST_PER_MESSAGE <= 0.10" | bc -l) )); then
    HEALTH_SCORE=$((HEALTH_SCORE + 30))
    HEALTH_REASONS+=("‚úÖ Efficient cost per message")
  elif (( $(echo "$COST_PER_MESSAGE <= 0.30" | bc -l) )); then
    HEALTH_SCORE=$((HEALTH_SCORE + 20))
    HEALTH_REASONS+=("‚úÖ Reasonable cost per message")
  elif (( $(echo "$COST_PER_MESSAGE <= 0.50" | bc -l) )); then
    HEALTH_SCORE=$((HEALTH_SCORE + 10))
    HEALTH_REASONS+=("‚ö†Ô∏è  Moderate cost per message")
  else
    HEALTH_SCORE=$((HEALTH_SCORE + 5))
    HEALTH_REASONS+=("‚ö†Ô∏è  High cost per message")
  fi
else
  HEALTH_SCORE=$((HEALTH_SCORE + 15))
fi

# Context growth component (0-30 points)
if [ "$FIRST_INPUT" -gt 0 ] && [ "$LATEST_INPUT" -gt 0 ]; then
  GROWTH_RATIO=$(echo "scale=1; $LATEST_INPUT / $FIRST_INPUT" | bc)
  [[ "$GROWTH_RATIO" == .* ]] && GROWTH_RATIO="0$GROWTH_RATIO"

  if (( $(echo "$GROWTH_RATIO < 3" | bc -l) )); then
    HEALTH_SCORE=$((HEALTH_SCORE + 30))
    HEALTH_REASONS+=("‚úÖ Healthy context size")
  elif (( $(echo "$GROWTH_RATIO < 5" | bc -l) )); then
    HEALTH_SCORE=$((HEALTH_SCORE + 20))
    HEALTH_REASONS+=("‚úÖ Moderate context growth")
  elif (( $(echo "$GROWTH_RATIO < 8" | bc -l) )); then
    HEALTH_SCORE=$((HEALTH_SCORE + 10))
    HEALTH_REASONS+=("‚ö†Ô∏è  Context growing significantly")
  else
    HEALTH_SCORE=$((HEALTH_SCORE + 5))
    HEALTH_REASONS+=("‚ö†Ô∏è  Context bloat detected")
  fi
else
  HEALTH_SCORE=$((HEALTH_SCORE + 15))
fi

# Determine health rating
if [ "$HEALTH_SCORE" -ge 90 ]; then
  HEALTH_RATING="‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê"
  HEALTH_STATUS="Excellent"
elif [ "$HEALTH_SCORE" -ge 75 ]; then
  HEALTH_RATING="‚≠ê‚≠ê‚≠ê‚≠ê"
  HEALTH_STATUS="Good"
elif [ "$HEALTH_SCORE" -ge 60 ]; then
  HEALTH_RATING="‚≠ê‚≠ê‚≠ê"
  HEALTH_STATUS="Fair"
elif [ "$HEALTH_SCORE" -ge 40 ]; then
  HEALTH_RATING="‚≠ê‚≠ê"
  HEALTH_STATUS="Poor"
else
  HEALTH_RATING="‚≠ê"
  HEALTH_STATUS="Critical"
fi

# ============================================================================
# PROMPT PATTERN ANALYSIS - Detect inefficient prompting patterns
# ============================================================================

# Extract user prompts for analysis
USER_PROMPT_ANALYSIS=$(jq -s '[.[] |
  select(.type == "user" and
         (.isMeta != true) and
         (.message.content | type == "string"))]' "$TRANSCRIPT_PATH")

# Pattern 1: Vague/broad questions
# Detect questions with broad keywords but no constraints
VAGUE_PROMPTS=$(echo "$USER_PROMPT_ANALYSIS" | jq '[.[] |
  select(.message.content |
    test("(?i)(explain|describe|tell me|how does|what is|show me)") and
    test("(?i)(brief|concise|summary|in \\\\d+ (points|words|lines)|limit|short)") | not
  )] | length')

VAGUE_PCT=0
if [ "$USER_MESSAGES" -gt 0 ]; then
  VAGUE_PCT=$(echo "scale=0; 100 * $VAGUE_PROMPTS / $USER_MESSAGES" | bc)
  [[ "$VAGUE_PCT" == .* ]] && VAGUE_PCT="0"
fi

VAGUE_DETECTED=false
VAGUE_SAVING=0
if [ "$VAGUE_PCT" -gt 30 ] && [ "$VAGUE_PROMPTS" -ge 2 ]; then
  VAGUE_DETECTED=true
  if [ "$USER_MESSAGES" -gt 0 ] && [ $(echo "$TOTAL_OUTPUT_COST > 0" | bc) -eq 1 ]; then
    VAGUE_SAVING=$(echo "scale=2; $TOTAL_OUTPUT_COST / $USER_MESSAGES * 0.25 * 10" | bc)
    [[ "$VAGUE_SAVING" == .* ]] && VAGUE_SAVING="0$VAGUE_SAVING"
  fi
fi

# Pattern 2: Large context pastes (>200 lines)
# Detect when users paste large blocks of code/text
LARGE_PASTE_COUNT=$(echo "$USER_PROMPT_ANALYSIS" | jq '[.[] |
  select((.message.content | split("\n") | length) > 200)] | length')

LARGE_PASTE_PCT=0
if [ "$USER_MESSAGES" -gt 0 ]; then
  LARGE_PASTE_PCT=$(echo "scale=0; 100 * $LARGE_PASTE_COUNT / $USER_MESSAGES" | bc)
  [[ "$LARGE_PASTE_PCT" == .* ]] && LARGE_PASTE_PCT="0"
fi

LARGE_PASTE_DETECTED=false
LARGE_PASTE_SAVING=0
if [ "$LARGE_PASTE_PCT" -gt 20 ] && [ "$LARGE_PASTE_COUNT" -ge 1 ]; then
  LARGE_PASTE_DETECTED=true
  if [ "$USER_MESSAGES" -gt 0 ]; then
    COMBINED_INPUT_COST=$(echo "scale=4; $TOTAL_INPUT_COST + $TOTAL_CACHE_WRITE_COST" | bc)
    [[ "$COMBINED_INPUT_COST" == .* ]] && COMBINED_INPUT_COST="0$COMBINED_INPUT_COST"
    if [ $(echo "$COMBINED_INPUT_COST > 0" | bc) -eq 1 ]; then
      LARGE_PASTE_SAVING=$(echo "scale=2; $COMBINED_INPUT_COST / $USER_MESSAGES * 0.20 * 10" | bc)
      [[ "$LARGE_PASTE_SAVING" == .* ]] && LARGE_PASTE_SAVING="0$LARGE_PASTE_SAVING"
    fi
  fi
fi

# Pattern 3: Repeated similar questions (low unique word diversity)
# Detect when user asks similar questions repeatedly (indicates unclear initial response)
AVG_UNIQUE_WORDS=$(echo "$USER_PROMPT_ANALYSIS" | jq '
  if length == 0 then 0 else
    (map(.message.content |
         ascii_downcase |
         gsub("[^a-z0-9 ]"; "") |
         split(" ") |
         unique |
         length) | add) / length
  end | floor')

REPEATED_DETECTED=false
REPEATED_SAVING=0
if [ "$USER_MESSAGES" -ge 3 ] && [ "$AVG_UNIQUE_WORDS" -lt 15 ] && [ "$AVG_UNIQUE_WORDS" -gt 0 ]; then
  REPEATED_DETECTED=true
  if [ $(echo "$COST_PER_MESSAGE > 0" | bc) -eq 1 ]; then
    REPEATED_SAVING=$(echo "scale=2; $COST_PER_MESSAGE * 0.15 * 10" | bc)
    [[ "$REPEATED_SAVING" == .* ]] && REPEATED_SAVING="0$REPEATED_SAVING"
  fi
fi

# Pattern 4: Missing task constraints
# Detect coding/task requests without format/length specifications
UNCONSTRAINED_TASKS=$(echo "$USER_PROMPT_ANALYSIS" | jq '[.[] |
  select(
    (.message.content | test("(?i)(write|create|build|implement|add|fix|refactor|generate)")) and
    (.message.content | test("(?i)(max|maximum|limit|under|less than|no more than|exactly|in \\\\d+|brief|concise|short|simple)") | not)
  )] | length')

UNCONSTRAINED_PCT=0
if [ "$USER_MESSAGES" -gt 0 ]; then
  UNCONSTRAINED_PCT=$(echo "scale=0; 100 * $UNCONSTRAINED_TASKS / $USER_MESSAGES" | bc)
  [[ "$UNCONSTRAINED_PCT" == .* ]] && UNCONSTRAINED_PCT="0"
fi

UNCONSTRAINED_DETECTED=false
UNCONSTRAINED_SAVING=0
if [ "$UNCONSTRAINED_PCT" -gt 40 ] && [ "$UNCONSTRAINED_TASKS" -ge 2 ]; then
  UNCONSTRAINED_DETECTED=true
  if [ "$USER_MESSAGES" -gt 0 ] && [ $(echo "$TOTAL_OUTPUT_COST > 0" | bc) -eq 1 ]; then
    UNCONSTRAINED_SAVING=$(echo "scale=2; $TOTAL_OUTPUT_COST / $USER_MESSAGES * 0.20 * 10" | bc)
    [[ "$UNCONSTRAINED_SAVING" == .* ]] && UNCONSTRAINED_SAVING="0$UNCONSTRAINED_SAVING"
  fi
fi

# ============================================================================
# GENERATE SMART RECOMMENDATIONS (Prioritized by savings)
# ============================================================================

declare -a RECOMMENDATIONS
declare -a REC_SAVINGS

# Recommendation 1: Model switching
if [ "$MODEL_COUNT" -gt 0 ]; then
  PRIMARY_MODEL="${MODEL_NAMES[0]}"
  if [[ "$PRIMARY_MODEL" == *"Opus"* ]] || [[ "$PRIMARY_MODEL" == *"Sonnet"* ]]; then
    POTENTIAL_SAVING=$(echo "scale=2; $COST_PER_MESSAGE * 0.75 * 10" | bc)
    [[ "$POTENTIAL_SAVING" == .* ]] && POTENTIAL_SAVING="0$POTENTIAL_SAVING"
    RECOMMENDATIONS+=("Switch to Haiku for simple tasks")
    REC_SAVINGS+=("$POTENTIAL_SAVING")
  fi
fi

# Recommendation 2: Output verbosity
if [ "$OUTPUT_TOKENS" -gt 0 ] && [ "$INPUT_TOKENS" -gt 0 ]; then
  if (( $(echo "$OUTPUT_INPUT_RATIO > 2.5" | bc -l) )); then
    POTENTIAL_SAVING=$(echo "scale=2; $COST_PER_MESSAGE * 0.25 * 10" | bc)
    [[ "$POTENTIAL_SAVING" == .* ]] && POTENTIAL_SAVING="0$POTENTIAL_SAVING"
    RECOMMENDATIONS+=("Ask for more concise responses")
    REC_SAVINGS+=("$POTENTIAL_SAVING")
  fi
fi

# Recommendation 3: Cache optimization
if [ "$TOTAL_CACHE_TOKENS" -gt 0 ]; then
  if (( $(echo "$CACHE_EFFICIENCY >= 70" | bc -l) )); then
    POTENTIAL_SAVING=$(echo "scale=2; $CACHE_READ_COST_SAVED / $USER_MESSAGES * 10" | bc)
    [[ "$POTENTIAL_SAVING" == .* ]] && POTENTIAL_SAVING="0$POTENTIAL_SAVING"
    RECOMMENDATIONS+=("Continue in session (cache working well)")
    REC_SAVINGS+=("$POTENTIAL_SAVING")
  elif (( $(echo "$CACHE_EFFICIENCY < 30" | bc -l) )); then
    POTENTIAL_SAVING=$(echo "scale=2; $COST_PER_MESSAGE * 0.15 * 10" | bc)
    [[ "$POTENTIAL_SAVING" == .* ]] && POTENTIAL_SAVING="0$POTENTIAL_SAVING"
    RECOMMENDATIONS+=("Use /clear to start fresh (cache inefficient)")
    REC_SAVINGS+=("$POTENTIAL_SAVING")
  fi
fi

# Recommendation 4: Context reset
if [ "$FIRST_INPUT" -gt 0 ] && [ "$LATEST_INPUT" -gt 0 ]; then
  GROWTH_RATIO=$(echo "scale=1; $LATEST_INPUT / $FIRST_INPUT" | bc)
  [[ "$GROWTH_RATIO" == .* ]] && GROWTH_RATIO="0$GROWTH_RATIO"

  if (( $(echo "$GROWTH_RATIO >= 5" | bc -l) )); then
    POTENTIAL_SAVING=$(echo "scale=2; $COST_PER_MESSAGE * 0.20 * 10" | bc)
    [[ "$POTENTIAL_SAVING" == .* ]] && POTENTIAL_SAVING="0$POTENTIAL_SAVING"
    RECOMMENDATIONS+=("Use /clear to reduce context size")
    REC_SAVINGS+=("$POTENTIAL_SAVING")
  fi
fi

# Recommendation 5: Vague prompts
if [ "$VAGUE_DETECTED" = true ]; then
  POTENTIAL_SAVING="$VAGUE_SAVING"
  RECOMMENDATIONS+=("Add constraints to questions (brief, in N points)")
  REC_SAVINGS+=("$POTENTIAL_SAVING")
fi

# Recommendation 6: Large pastes
if [ "$LARGE_PASTE_DETECTED" = true ]; then
  POTENTIAL_SAVING="$LARGE_PASTE_SAVING"
  RECOMMENDATIONS+=("Use file references instead of pasting large code")
  REC_SAVINGS+=("$POTENTIAL_SAVING")
fi

# Recommendation 7: Repeated questions
if [ "$REPEATED_DETECTED" = true ]; then
  POTENTIAL_SAVING="$REPEATED_SAVING"
  RECOMMENDATIONS+=("Ask complete questions upfront (avoid iterations)")
  REC_SAVINGS+=("$POTENTIAL_SAVING")
fi

# Recommendation 8: Unconstrained tasks
if [ "$UNCONSTRAINED_DETECTED" = true ]; then
  POTENTIAL_SAVING="$UNCONSTRAINED_SAVING"
  RECOMMENDATIONS+=("Specify format/length constraints for tasks")
  REC_SAVINGS+=("$POTENTIAL_SAVING")
fi

# Sort recommendations by savings (bubble sort for bash compatibility)
REC_COUNT=${#RECOMMENDATIONS[@]}
for ((i=0; i<REC_COUNT-1; i++)); do
  for ((j=0; j<REC_COUNT-i-1; j++)); do
    if (( $(echo "${REC_SAVINGS[j]} < ${REC_SAVINGS[j+1]}" | bc -l) )); then
      # Swap
      temp_rec="${RECOMMENDATIONS[j]}"
      temp_sav="${REC_SAVINGS[j]}"
      RECOMMENDATIONS[j]="${RECOMMENDATIONS[j+1]}"
      REC_SAVINGS[j]="${REC_SAVINGS[j+1]}"
      RECOMMENDATIONS[j+1]="$temp_rec"
      REC_SAVINGS[j+1]="$temp_sav"
    fi
  done
done

# ============================================================================
# OUTPUT DISPLAY - Enhanced visual hierarchy
# ============================================================================

# Quick summary line
TREND_INDICATOR="‚û°Ô∏è"
TREND_TEXT="Stable"
if [ "$USER_MESSAGES" -gt 2 ]; then
  EARLY_MSGS=2
  LATE_START=$((USER_MESSAGES - 2))
  if [ "$LATE_START" -gt "$EARLY_MSGS" ]; then
    EARLY_COST=$(echo "scale=4; $ESTIMATE_TOTAL_COST / $USER_MESSAGES * $EARLY_MSGS" | bc)
    LATE_COST=$(echo "scale=4; $ESTIMATE_TOTAL_COST - ($ESTIMATE_TOTAL_COST / $USER_MESSAGES * $LATE_START)" | bc)
    EARLY_AVG=$(echo "scale=4; $EARLY_COST / $EARLY_MSGS" | bc)
    LATE_AVG=$(echo "scale=4; $LATE_COST / 2" | bc)

    [[ "$EARLY_AVG" == .* ]] && EARLY_AVG="0$EARLY_AVG"
    [[ "$LATE_AVG" == .* ]] && LATE_AVG="0$LATE_AVG"

    if (( $(echo "$LATE_AVG > $EARLY_AVG * 1.2" | bc -l) )); then
      TREND_INDICATOR="‚ûö"
      TREND_TEXT="Rising"
    elif (( $(echo "$LATE_AVG < $EARLY_AVG * 0.8" | bc -l) )); then
      TREND_INDICATOR="‚ûò"
      TREND_TEXT="Falling"
    fi
  fi
fi

ACTION_TEXT="Review insights below"
if [ ${#RECOMMENDATIONS[@]} -gt 0 ]; then
  ACTION_TEXT="See top ${#RECOMMENDATIONS[@]} optimization tips"
fi

echo ""
echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
echo "‚ïë  üöó TRIP COMPUTER v0.6.1  ‚îÇ  \$$ESTIMATE_TOTAL_COST session  ‚îÇ  ${CACHE_EFFICIENCY}% efficient  ‚ïë"
echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
echo ""
echo "üìä QUICK SUMMARY"
echo "  Status: $HEALTH_STATUS ($HEALTH_SCORE/100)  ‚îÇ  Trend: $TREND_INDICATOR $TREND_TEXT  ‚îÇ  Action: $ACTION_TEXT"
echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo ""

# ============================================================================
# SESSION HEALTH SCORE
# ============================================================================

echo "üìà SESSION HEALTH: $HEALTH_SCORE/100  $HEALTH_RATING"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
for reason in "${HEALTH_REASONS[@]}"; do
  echo "  $reason"
done
echo ""

# ============================================================================
# MODEL MIX
# ============================================================================

if [ "$MODEL_COUNT" -gt 0 ]; then
  echo "ü§ñ MODEL MIX"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

  for ((i=0; i<MODEL_COUNT; i++)); do
    MODEL_NAME="${MODEL_NAMES[i]}"
    MODEL_COST="${MODEL_COSTS[i]}"
    MODEL_REQ="${MODEL_REQUESTS[i]}"

    # Calculate percentage
    if (( $(echo "$ESTIMATE_TOTAL_COST > 0" | bc -l) )); then
      MODEL_PCT=$(echo "scale=0; 100 * $MODEL_COST / $ESTIMATE_TOTAL_COST" | bc)
      [[ "$MODEL_PCT" == .* ]] && MODEL_PCT="0"
    else
      MODEL_PCT=0
    fi

    # Create visual bar (20 chars max)
    BAR_LENGTH=$(echo "scale=0; $MODEL_PCT / 5" | bc)
    [[ "$BAR_LENGTH" == .* ]] && BAR_LENGTH="0"
    BAR=$(printf '‚ñà%.0s' $(seq 1 $BAR_LENGTH))
    BAR="${BAR}$(printf '‚ñë%.0s' $(seq 1 $((20 - BAR_LENGTH))))"

    printf "  %-12s %2d calls ‚Üí \$%-8s (%3d%%)  %s\n" "$MODEL_NAME:" "$MODEL_REQ" "$MODEL_COST" "$MODEL_PCT" "$BAR"
  done

  # Model switching suggestion
  if [ "$MODEL_COUNT" -eq 1 ]; then
    PRIMARY_MODEL="${MODEL_NAMES[0]}"
    if [[ "$PRIMARY_MODEL" == *"Opus"* ]]; then
      HAIKU_COST=$(echo "scale=2; $ESTIMATE_TOTAL_COST * 0.20" | bc)
      [[ "$HAIKU_COST" == .* ]] && HAIKU_COST="0$HAIKU_COST"
      echo ""
      echo "  üí° Switching Opus ‚Üí Haiku could save ~\$$(echo "scale=2; $ESTIMATE_TOTAL_COST - $HAIKU_COST" | bc) (80% reduction)"
    elif [[ "$PRIMARY_MODEL" == *"Sonnet"* ]]; then
      HAIKU_COST=$(echo "scale=2; $ESTIMATE_TOTAL_COST * 0.33" | bc)
      [[ "$HAIKU_COST" == .* ]] && HAIKU_COST="0$HAIKU_COST"
      echo ""
      echo "  üí° Switching Sonnet ‚Üí Haiku could save ~\$$(echo "scale=2; $ESTIMATE_TOTAL_COST - $HAIKU_COST" | bc) (67% reduction)"
    fi
  fi
  echo ""
fi

# ============================================================================
# COST DRIVERS BREAKDOWN
# ============================================================================

echo "üíµ COST DRIVERS"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

# Calculate percentages
if (( $(echo "$ESTIMATE_TOTAL_COST > 0" | bc -l) )); then
  INPUT_PCT=$(echo "scale=0; 100 * $TOTAL_INPUT_COST / $ESTIMATE_TOTAL_COST" | bc)
  OUTPUT_PCT=$(echo "scale=0; 100 * $TOTAL_OUTPUT_COST / $ESTIMATE_TOTAL_COST" | bc)
  CACHE_WRITE_PCT=$(echo "scale=0; 100 * $TOTAL_CACHE_WRITE_COST / $ESTIMATE_TOTAL_COST" | bc)
  CACHE_READ_PCT=$(echo "scale=0; 100 * $TOTAL_CACHE_READ_COST / $ESTIMATE_TOTAL_COST" | bc)

  [[ "$INPUT_PCT" == .* ]] && INPUT_PCT="0"
  [[ "$OUTPUT_PCT" == .* ]] && OUTPUT_PCT="0"
  [[ "$CACHE_WRITE_PCT" == .* ]] && CACHE_WRITE_PCT="0"
  [[ "$CACHE_READ_PCT" == .* ]] && CACHE_READ_PCT="0"
else
  INPUT_PCT=0
  OUTPUT_PCT=0
  CACHE_WRITE_PCT=0
  CACHE_READ_PCT=0
fi

# Create visual bars
INPUT_BAR_LEN=$(echo "scale=0; $INPUT_PCT / 5" | bc)
OUTPUT_BAR_LEN=$(echo "scale=0; $OUTPUT_PCT / 5" | bc)
CACHE_W_BAR_LEN=$(echo "scale=0; $CACHE_WRITE_PCT / 5" | bc)
CACHE_R_BAR_LEN=$(echo "scale=0; $CACHE_READ_PCT / 5" | bc)

[[ "$INPUT_BAR_LEN" == .* ]] && INPUT_BAR_LEN="0"
[[ "$OUTPUT_BAR_LEN" == .* ]] && OUTPUT_BAR_LEN="0"
[[ "$CACHE_W_BAR_LEN" == .* ]] && CACHE_W_BAR_LEN="0"
[[ "$CACHE_R_BAR_LEN" == .* ]] && CACHE_R_BAR_LEN="0"

INPUT_BAR=$(printf '‚ñà%.0s' $(seq 1 $INPUT_BAR_LEN))$(printf '‚ñë%.0s' $(seq 1 $((20 - INPUT_BAR_LEN))))
OUTPUT_BAR=$(printf '‚ñà%.0s' $(seq 1 $OUTPUT_BAR_LEN))$(printf '‚ñë%.0s' $(seq 1 $((20 - OUTPUT_BAR_LEN))))
CACHE_W_BAR=$(printf '‚ñà%.0s' $(seq 1 $CACHE_W_BAR_LEN))$(printf '‚ñë%.0s' $(seq 1 $((20 - CACHE_W_BAR_LEN))))
CACHE_R_BAR=$(printf '‚ñà%.0s' $(seq 1 $CACHE_R_BAR_LEN))$(printf '‚ñë%.0s' $(seq 1 $((20 - CACHE_R_BAR_LEN))))

printf "  %-18s \$%-8s (%3d%%)  %s\n" "Input tokens:" "$TOTAL_INPUT_COST" "$INPUT_PCT" "$INPUT_BAR"
printf "  %-18s \$%-8s (%3d%%)  %s\n" "Output tokens:" "$TOTAL_OUTPUT_COST" "$OUTPUT_PCT" "$OUTPUT_BAR"
printf "  %-18s \$%-8s (%3d%%)  %s\n" "Cache writes:" "$TOTAL_CACHE_WRITE_COST" "$CACHE_WRITE_PCT" "$CACHE_W_BAR"
printf "  %-18s \$%-8s (%3d%%)  %s\n" "Cache reads:" "$TOTAL_CACHE_READ_COST" "$CACHE_READ_PCT" "$CACHE_R_BAR"

# Cost driver insights
echo ""
if [ "$OUTPUT_PCT" -gt 60 ]; then
  echo "  ‚ö†Ô∏è  Output tokens are your biggest cost driver (${OUTPUT_PCT}%) - consider asking for brevity"
elif [ "$INPUT_PCT" -gt 60 ]; then
  echo "  ‚ö†Ô∏è  Input tokens are your biggest cost driver (${INPUT_PCT}%) - context may be large"
elif [ "$CACHE_WRITE_PCT" -gt 40 ]; then
  echo "  ‚ö†Ô∏è  Cache writes are expensive (${CACHE_WRITE_PCT}%) - consider using /clear if cache not helping"
else
  echo "  ‚úì Balanced cost distribution across token types"
fi
echo ""

# ============================================================================
# EFFICIENCY METRICS
# ============================================================================

echo "‚ö° EFFICIENCY METRICS"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "  Output/Input Ratio: ${OUTPUT_INPUT_RATIO}x"
if (( $(echo "$OUTPUT_INPUT_RATIO > 3.0" | bc -l) )); then
  echo "                      ‚Üí AI is verbose - consider asking for brevity"
elif (( $(echo "$OUTPUT_INPUT_RATIO < 1.0" | bc -l) )); then
  echo "                      ‚Üí AI is concise - good efficiency"
else
  echo "                      ‚Üí Typical verbosity level"
fi
echo ""
echo "  Cache Hit Rate:     ${CACHE_EFFICIENCY}%"
if (( $(echo "$CACHE_EFFICIENCY >= 70" | bc -l) )); then
  echo "                      ‚Üí Excellent - stay in session (saved ~\$$CACHE_READ_COST_SAVED)"
elif (( $(echo "$CACHE_EFFICIENCY >= 40" | bc -l) )); then
  echo "                      ‚Üí Moderate - session working OK"
elif [ "$TOTAL_CACHE_TOKENS" -gt 0 ]; then
  echo "                      ‚Üí Low - consider /clear to refresh"
else
  echo "                      ‚Üí No cache data yet"
fi
echo ""
printf "  Cost per Token:     \$%.8f\n" "$COST_PER_TOKEN"
echo ""

# ============================================================================
# USAGE SECTION - Different for API vs Subscription
# ============================================================================

if [ "$BILLING_MODE" = "Sub" ]; then
  USAGE_HEADER="üìä SESSION USAGE ESTIMATE"
  USAGE_NOTE="  üìå Your usage is included in subscription - no charges."
  USAGE_NOTE2="     These API-equivalent estimates help you understand rate limit impact."
else
  USAGE_HEADER="üìä SESSION USAGE ESTIMATE (API Billing)"
  USAGE_NOTE="  üí° Run /cost separately to see official billing data and compare accuracy."
  USAGE_NOTE2="     Estimates are typically within 10% of actual costs."
fi

echo "$USAGE_HEADER"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "  Messages: $USER_MESSAGES | Tools: $TOOL_CALLS | Cost: ~\$$ESTIMATE_TOTAL_COST"
echo "  Cache Efficiency: ${CACHE_EFFICIENCY}% | Tokens: $(printf "%'d" $TOTAL_TOKENS)"
echo ""
echo "  Token Breakdown:"
echo "    Input: $(printf "%'d" $INPUT_TOKENS) | Output: $(printf "%'d" $OUTPUT_TOKENS)"
echo "    Cache Writes: $(printf "%'d" $CACHE_CREATION_TOKENS) | Cache Reads: $(printf "%'d" $CACHE_READ_TOKENS)"
echo ""
echo "$USAGE_NOTE"
if [ -n "$USAGE_NOTE2" ]; then
  echo "$USAGE_NOTE2"
fi

echo ""

# ============================================================================
# SMART RECOMMENDATIONS (Prioritized by savings)
# ============================================================================

if [ ${#RECOMMENDATIONS[@]} -gt 0 ]; then
  echo "üéØ TOP OPTIMIZATION ACTIONS (by potential savings)"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

  DISPLAY_COUNT=$((${#RECOMMENDATIONS[@]} < 3 ? ${#RECOMMENDATIONS[@]} : 3))
  for ((i=0; i<DISPLAY_COUNT; i++)); do
    REC_NUM=$((i + 1))
    REC_TEXT="${RECOMMENDATIONS[i]}"
    REC_SAVE="${REC_SAVINGS[i]}"

    if (( $(echo "$REC_SAVE > 0.01" | bc -l) )); then
      SAVINGS_TEXT="Save ~\$$REC_SAVE/10 msgs"
      REDUCTION_PCT=$(echo "scale=0; 100 * $REC_SAVE / ($COST_PER_MESSAGE * 10)" | bc)
      [[ "$REDUCTION_PCT" == .* ]] && REDUCTION_PCT="0"
      if [ "$REDUCTION_PCT" -gt 0 ]; then
        SAVINGS_TEXT="$SAVINGS_TEXT (${REDUCTION_PCT}% reduction)"
      fi
    else
      SAVINGS_TEXT="Optimize session health"
    fi

    echo "  $REC_NUM. $REC_TEXT"
    echo "     ‚Üí $SAVINGS_TEXT"
  done
  echo ""
else
  echo "üí° INSIGHTS"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo "  ‚úì Session efficiency looks good - continue with current workflow"
  echo ""
fi

# ============================================================================
# TRAJECTORY
# ============================================================================

echo "üìà TRAJECTORY"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "  At current rate (\$${COST_PER_MESSAGE}/msg):"
if [ "$USER_MESSAGES" -gt 0 ]; then
  PROJECTED_10=$(echo "scale=2; $COST_PER_MESSAGE * 10" | bc)
  [[ "$PROJECTED_10" == .* ]] && PROJECTED_10="0$PROJECTED_10"
  echo "    ‚Ä¢ Next 10 messages: ~\$$PROJECTED_10"

  HOURLY_MSGS=$(echo "scale=0; 60 / ($USER_MESSAGES / 1)" | bc 2>/dev/null || echo "N/A")
  if [ "$HOURLY_MSGS" != "N/A" ] && [ "$HOURLY_MSGS" -gt 0 ]; then
    HOURLY_COST=$(echo "scale=2; $COST_PER_MESSAGE * $HOURLY_MSGS" | bc)
    [[ "$HOURLY_COST" == .* ]] && HOURLY_COST="0$HOURLY_COST"
    echo "    ‚Ä¢ Projected hourly rate: ~\$$HOURLY_COST at current pace"
  fi
else
  echo "    ‚Ä¢ Next 10 messages: N/A (no messages yet)"
fi
echo ""

echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo ""
echo "üìÅ Session: $SESSION_ID"
echo ""

exit 0
SCRIPT_EOF

chmod +x ~/.claude/hooks/show-session-stats.sh
echo "‚úì Installed show-session-stats.sh (detailed stats)"

# Create slash command
cat > ~/.claude/commands/trip-computer.md << 'COMMAND_EOF'
---
description: Display trip computer analytics for the current session (rate, efficiency, cost drivers, recommendations)
---

Execute the session statistics script and display its output directly in your message text (not in a code block) so it's immediately visible without requiring expansion:

1. Run: ~/.claude/hooks/show-session-stats.sh
2. Capture the output
3. Display the full output as plain text in your response
4. Do not add any commentary, analysis, or interpretation - just show the trip computer output
COMMAND_EOF

echo "‚úì Created /trip-computer command"
echo ""

echo "Configuring status line..."

# Configure settings.json
SETTINGS_FILE="$HOME/.claude/settings.json"

# Get absolute path to script and check for spaces
SCRIPT_PATH="$HOME/.claude/hooks/brief-stats.sh"

# Check if path contains spaces - if so, wrap with bash command
if [[ "$SCRIPT_PATH" == *" "* ]]; then
  # Path has spaces - use bash wrapper (jq will handle JSON escaping)
  STATUS_COMMAND="bash \"$SCRIPT_PATH\""
  echo "‚úì Detected spaces in path, using bash wrapper"
else
  # No spaces - use simple path
  STATUS_COMMAND="~/.claude/hooks/brief-stats.sh"
fi

if [ -f "$SETTINGS_FILE" ]; then
  # Backup existing settings
  cp "$SETTINGS_FILE" "${SETTINGS_FILE}.backup"
  echo "‚úì Backed up existing settings to settings.json.backup"

  # Update statusLine using jq
  jq --arg cmd "$STATUS_COMMAND" '.statusLine = {"type": "command", "command": $cmd}' \
    "$SETTINGS_FILE" > "${SETTINGS_FILE}.tmp" && mv "${SETTINGS_FILE}.tmp" "$SETTINGS_FILE"
  echo "‚úì Updated ~/.claude/settings.json"
else
  # Create new settings file
  jq -n --arg cmd "$STATUS_COMMAND" '{statusLine: {type: "command", command: $cmd}}' > "$SETTINGS_FILE"
  echo "‚úì Created ~/.claude/settings.json"
fi

echo ""
echo "Testing installation..."

# Test brief-stats.sh
BRIEF_OUTPUT=$(~/.claude/hooks/brief-stats.sh 2>&1)
if [ $? -eq 0 ]; then
  echo "‚úì Status line script works: $BRIEF_OUTPUT"
else
  echo "‚ö†Ô∏è  Status line script error (may be normal if no sessions exist yet)"
fi

# Test show-session-stats.sh
DETAIL_OUTPUT=$(~/.claude/hooks/show-session-stats.sh 2>&1 | head -3)
if [ $? -eq 0 ]; then
  echo "‚úì Detailed stats script works"
else
  echo "‚ö†Ô∏è  Detailed stats script error (may be normal if no sessions exist yet)"
fi

echo ""
echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
echo "‚ïë                  Installation Complete! ‚úì                  ‚ïë"
echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
echo ""
echo "What's installed:"
echo "  ‚Ä¢ Status line hook:  ~/.claude/hooks/brief-stats.sh"
echo "  ‚Ä¢ Detailed stats:    ~/.claude/hooks/show-session-stats.sh"
echo "  ‚Ä¢ Slash command:     /trip-computer"
echo "  ‚Ä¢ Configuration:     ~/.claude/settings.json"
echo "  ‚Ä¢ Billing config:    ~/.claude/hooks/.stats-config"
echo ""
echo "Next steps:"
echo "  1. Restart Claude Code to see the status line"
echo "  2. Type /trip-computer to view detailed analytics"
echo "  3. Check the status bar at the bottom of Claude Code"
echo ""
echo "What you'll see in the status line:"
echo "  üí¨ X msgs | üîß X tools | üéØ XK tok | üí≥ API ~\$X.XX"
echo "  or"
echo "  üí¨ X msgs | üîß X tools | üéØ XK tok | üìÖ Sub ~\$X.XX"
echo ""
echo "Features:"
echo "  ‚úì User-configured billing mode ($BILLING_MODE)"
echo "  ‚úì Model-specific pricing (Opus, Sonnet, Haiku)"
echo "  ‚úì Agent activity indicator"
echo "  ‚úì Accurate token deduplication"
echo "  ‚úì Session-level cost tracking"
echo ""
echo "Enjoy your new stats tracking! üöÄ"
